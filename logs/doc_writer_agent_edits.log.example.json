[
    {
        "path": "docs/docs/weaviate/concepts/cluster.md",
        "edits": [
            {
                "path": "docs/docs/weaviate/concepts/cluster.md",
                "edits": [
                    {
                        "replace_section": "## Shard replica movement\n\n:::info Added in `v1.32`\n:::\n\nA shard replica can be moved or copied from one node to another. This is useful when you want to balance the load across nodes or when you want to change the replication factor of a part of a collection.\n\n[See this page](/docs/deploy/configuration/replica-movement.mdx) for more details on how to move shard replicas.\n\n### Use cases for moving shard replicas\n\n1. **Load Balancing**: If certain nodes are experiencing higher loads than others, moving shard replicas can help distribute the load more evenly across the cluster.\n\n2. **Scaling**: If you need to scale your cluster (e.g., adding more nodes to handle increased load), shard replicas can be moved to the new nodes to ensure that the data is evenly distributed across the cluster.\n\n3. **Node Maintenance or Replacement**: If a node requires maintenance (e.g., hardware upgrades) or replacement, shard replicas can be moved to temporary or replacement nodes to ensure continuous availability during the maintenance window.",
                        "replacement_txt": "## Shard replica movement\n\n:::info Added in `v1.32`\n:::\n\nA shard replica can be moved or copied from one node to another. This is useful when you want to balance the load across nodes or when you want to change the replication factor of a part of a collection.\n\n[See this page](/docs/deploy/configuration/replica-movement.mdx) for more details on how to move shard replicas.\n\n### Use cases for moving shard replicas\n\n1. **Load Balancing**: If certain nodes are experiencing higher loads than others, moving shard replicas can help distribute the load more evenly across the cluster.\n\n2. **Scaling**: If you need to scale your cluster (e.g., adding more nodes to handle increased load), shard replicas can be moved to the new nodes to ensure that the data is evenly distributed across the cluster.\n\n3. **Node Maintenance or Replacement**: If a node requires maintenance (e.g., hardware upgrades) or replacement, shard replicas can be moved to temporary or replacement nodes to ensure continuous availability during the maintenance window.\n\n## Cluster Resharding\n\nWeaviate supports dynamic cluster resharding, which allows administrators to redistribute data across nodes in a multi-node cluster without downtime. This feature enables you to adjust the number of shards in an existing cluster to improve performance and scalability.\n\nThe resharding process works by creating new shard mappings, migrating vector embeddings and metadata in batches, and updating the distributed hash ring to reflect the new topology.\n\n### Key capabilities\n\n* **Automatic load balancing**: The migration process includes automatic load balancing to prevent node overload during data redistribution.\n* **Configurable performance**: You can configure batch sizes and migration speed throttling to control the impact on cluster performance.\n* **Data integrity**: Real-time consistency checks ensure data integrity throughout the migration process.\n* **Rollback support**: The system supports rollback capabilities in case of migration failures.\n* **Progress monitoring**: Dedicated monitoring endpoints allow you to track resharding progress in real-time.\n\n### Resharding operation\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n- Target shard count\n- Migration speed settings\n- Validation configuration\n\nDuring the resharding process:\n- **Read operations** continue normally without interruption\n- **Write operations** are temporarily queued and replayed after shard migration completes\n\n### Typical use cases\n\nCluster resharding is particularly useful for:\n\n1. **Scaling under load**: Redistributing shards when scaling up clusters experiencing heavy load\n2. **Rebalancing after node changes**: Optimizing shard distribution after adding or removing nodes from the cluster\n3. **Performance optimization**: Adjusting shard distribution to match query performance patterns and workload characteristics\n\nFor detailed API usage and configuration options, see the [multi-node setup documentation](/docs/weaviate/manage-collections/multi-node-setup.mdx)."
                    },
                    {
                        "replace_section": "## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* As of `v1.8.0`, dynamically scaling a cluster is not fully supported yet. New nodes can be added to an existing cluster, however it does not affect the ownership of shards. Existing nodes can not yet be removed if data is present, as shards are not yet being moved to other nodes prior to a removal of a node.",
                        "replacement_txt": "## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* Weaviate now supports dynamic cluster scaling through the resharding feature, which allows you to redistribute data across nodes without downtime. This enables adding new nodes and rebalancing existing shards, as well as optimizing shard distribution for improved performance."
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    },
    {
        "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md)."
                    }
                ],
                "referenced_file_edits": {
                    "docs/_includes/code/howto/manage-data.collections.py": [
                        {
                            "replace_section": "client.close()",
                            "replacement_txt": "# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()"
                        }
                    ],
                    "docs/_includes/code/howto/manage-data.collections.ts": [
                        {
                            "replace_section": "// END MultiValueVectorCollection",
                            "replacement_txt": "// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding"
                        }
                    ],
                    "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java": [
                        {
                            "replace_section": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n}",
                            "replacement_txt": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}"
                        }
                    ],
                    "docs/_includes/code/howto/go/docs/manage-data.classes_test.go": [
                        {
                            "replace_section": "\t\trequire.NoError(t, err)\n\t})\n}",
                            "replacement_txt": "\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}"
                        }
                    ]
                }
            }
        ]
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.py",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md)."
                    }
                ],
                "referenced_file_edits": {
                    "docs/_includes/code/howto/manage-data.collections.py": [
                        {
                            "replace_section": "client.close()",
                            "replacement_txt": "# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()"
                        }
                    ],
                    "docs/_includes/code/howto/manage-data.collections.ts": [
                        {
                            "replace_section": "// END MultiValueVectorCollection",
                            "replacement_txt": "// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding"
                        }
                    ],
                    "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java": [
                        {
                            "replace_section": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n}",
                            "replacement_txt": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}"
                        }
                    ],
                    "docs/_includes/code/howto/go/docs/manage-data.classes_test.go": [
                        {
                            "replace_section": "\t\trequire.NoError(t, err)\n\t})\n}",
                            "replacement_txt": "\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}"
                        }
                    ]
                }
            }
        ]
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.ts",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md)."
                    }
                ],
                "referenced_file_edits": {
                    "docs/_includes/code/howto/manage-data.collections.py": [
                        {
                            "replace_section": "client.close()",
                            "replacement_txt": "# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()"
                        }
                    ],
                    "docs/_includes/code/howto/manage-data.collections.ts": [
                        {
                            "replace_section": "// END MultiValueVectorCollection",
                            "replacement_txt": "// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding"
                        }
                    ],
                    "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java": [
                        {
                            "replace_section": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n}",
                            "replacement_txt": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}"
                        }
                    ],
                    "docs/_includes/code/howto/go/docs/manage-data.classes_test.go": [
                        {
                            "replace_section": "\t\trequire.NoError(t, err)\n\t})\n}",
                            "replacement_txt": "\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}"
                        }
                    ]
                }
            }
        ]
    },
    {
        "path": "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md)."
                    }
                ],
                "referenced_file_edits": {
                    "docs/_includes/code/howto/manage-data.collections.py": [
                        {
                            "replace_section": "client.close()",
                            "replacement_txt": "# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()"
                        }
                    ],
                    "docs/_includes/code/howto/manage-data.collections.ts": [
                        {
                            "replace_section": "// END MultiValueVectorCollection",
                            "replacement_txt": "// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding"
                        }
                    ],
                    "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java": [
                        {
                            "replace_section": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n}",
                            "replacement_txt": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}"
                        }
                    ],
                    "docs/_includes/code/howto/go/docs/manage-data.classes_test.go": [
                        {
                            "replace_section": "\t\trequire.NoError(t, err)\n\t})\n}",
                            "replacement_txt": "\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}"
                        }
                    ]
                }
            }
        ]
    },
    {
        "path": "docs/_includes/code/howto/go/docs/manage-data.classes_test.go",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md)."
                    }
                ],
                "referenced_file_edits": {
                    "docs/_includes/code/howto/manage-data.collections.py": [
                        {
                            "replace_section": "client.close()",
                            "replacement_txt": "# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()"
                        }
                    ],
                    "docs/_includes/code/howto/manage-data.collections.ts": [
                        {
                            "replace_section": "// END MultiValueVectorCollection",
                            "replacement_txt": "// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding"
                        }
                    ],
                    "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java": [
                        {
                            "replace_section": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n}",
                            "replacement_txt": "    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}"
                        }
                    ],
                    "docs/_includes/code/howto/go/docs/manage-data.classes_test.go": [
                        {
                            "replace_section": "\t\trequire.NoError(t, err)\n\t})\n}",
                            "replacement_txt": "\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}"
                        }
                    ]
                }
            }
        ]
    },
    {
        "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
        "edits": [
            {
                "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
                "edits": [
                    {
                        "replace_section": "On the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n\n## Replication Factor",
                        "replacement_txt": "On the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n## Dynamic Resharding\n\nWeaviate's cluster architecture supports dynamic resharding, which allows administrators to redistribute data across nodes in a multi-node cluster without downtime. This capability enhances the leaderless replication design by providing operational flexibility to optimize performance and scalability as cluster requirements evolve.\n\n### Resharding Architecture\n\nThe resharding mechanism integrates seamlessly with Weaviate's existing cluster architecture:\n\n1. **Shard Mapping Creation**: The system creates new shard mappings to define how data will be redistributed across the cluster nodes\n2. **Batch Migration**: Vector embeddings and metadata are migrated in configurable batches to prevent overwhelming individual nodes\n3. **Distributed Hash Ring Update**: The cluster's distributed hash ring is updated to reflect the new shard topology\n4. **Coordination Integration**: The resharding process works within the existing coordinator node pattern, ensuring the leaderless architecture remains intact\n\n### Operational Benefits\n\nDynamic resharding provides several architectural advantages:\n\n- **Automatic Load Balancing**: During migration, the system automatically balances the load to prevent any single node from becoming overwhelmed\n- **Configurable Migration Speed**: Batch sizes and migration speed can be throttled to control the impact on cluster performance\n- **Real-time Consistency Checks**: The system performs continuous data integrity validation during the resharding process\n- **Rollback Support**: Built-in rollback capabilities provide operational safety in case of migration failures\n- **Monitoring Integration**: Dedicated monitoring endpoints track resharding progress and system health\n\n### Impact on Read/Write Operations\n\nResharding is designed to minimize disruption to the cluster's normal operations:\n\n- **Read Operations**: Continue normally during the resharding process, maintaining query availability\n- **Write Operations**: Are temporarily queued during shard migration and replayed after the migration completes for the affected shards\n- **Coordinator Pattern**: The existing coordinator node pattern remains unchanged, ensuring seamless client interaction\n\n### Use Cases\n\nDynamic resharding supports several operational scenarios:\n\n- **Scaling Under Load**: Redistribute shards when clusters experience heavy load to improve performance\n- **Node Management**: Rebalance data after adding or removing nodes from the cluster\n- **Performance Optimization**: Adjust shard distribution based on query performance patterns and access frequencies\n\n:::info Implementation Details\nFor specific implementation guidance on triggering resharding operations, see the [cluster management documentation](/deploy/configuration/cluster-management.md). Client library support for resharding operations is available across all Weaviate SDKs.\n:::\n\n## Replication Factor"
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    }
]