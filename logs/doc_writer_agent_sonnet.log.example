[
    {
        "path": "docs/docs/weaviate/concepts/cluster.md",
        "revised_doc": "---\ntitle: Horizontal Scaling\nsidebar_position: 30\ndescription: \"Multi-node cluster architecture and horizontal scaling strategies for high-availability Weaviate deployments.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture', 'horizontal scaling', 'cluster', 'replication', 'sharding']\n---\n\nWeaviate can be scaled horizontally by being run on a set of multiple nodes in a cluster. This section lays out various ways in which Weaviate can be scaled, as well as factors to consider while scaling, and Weaviate's architecture in relation to horizontal scaling.\n\n## Basic concepts\n\n### Shards\n\nA collection in Weaviate comprises of one or more \"shards\", which are the basic units of data storage and retrieval. A shard will contain its own vector index, inverted indexes, and object store. Each shard can be hosted on a different node, allowing for distributed data storage and processing.\n\n![Shards explained](./img/shards_explained.png)\n\nThe number of unique shards in a single-tenant collection can only be set at collection creation time. In most cases, letting Weaviate manage the number of shards is sufficient. But in some cases, you may want to manually configure the number of shards for performance or data distribution reasons.\n\nIn a multi-tenant collection, each tenant consists of one shard. This means that the number of unique shards in a multi-tenant collection is equal to the number of tenants.\n\n![Shards in collections](./img/shards_in_collections.png)\n\n### Replicas\n\nDepending on the setup, each shard can have one or more \"replicas\", to be hosted on different nodes. This is referred to as a \"high availability\" setup, where the same data is available on multiple nodes. This allows for better read throughput and fault tolerance.\n\nYou can set the desired number of replicas, also called a replication factor, in Weaviate. This can be set a global cluster-level default using the [`REPLICATION_MINIMUM_FACTOR` environment variable](/docs/deploy/configuration/env-vars/index.md). It can also be set [per collection](/docs/weaviate/manage-collections/multi-node-setup.mdx#replication-settings), which will override the global default.\n\n## Motivation to scale Weaviate\nGenerally there are (at least) three distinct motivations to scale out horizontally which all will lead to different setups.\n\n### Motivation 1: Maximum Dataset Size\nDue to the [memory footprint of an HNSW graph](./resources.md#the-role-of-memory) it may be desirable to spread a dataset across multiple servers (\"nodes\"). In such a setup, a single collection may be split into shards and shards are spread across nodes.\n\nWeaviate does the required orchestration at import and query time fully automatically.\n\nSee [Sharding vs Replication](#sharding-vs-replication) below for trade-offs involved when running multiple shards.\n\n**Solution: Sharding across multiple nodes in a cluster**\n\n:::note\nThe ability to shard across a cluster was added in Weaviate `v1.8.0`.\n:::\n\n### Motivation 2: Higher Query Throughput\nWhen you receive more queries than a single Weaviate node can handle, it is desirable to add more Weaviate nodes which can help in responding to your users' queries.\n\nInstead of sharding across multiple nodes, you can replicate (the same data) across multiple nodes. This process also happens fully automatically and you only need to specify the desired replication factor. Sharding and replication can also be combined.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n### Motivation 3: High Availability\n\nWhen serving critical loads with Weaviate, it may be desirable to be able to keep serving queries even if a node fails completely. Such a failure could be either due to a software or OS-level crash or even a hardware issue. Other than unexpected crashes, a highly available setup can also tolerate zero-downtime updates and other maintenance tasks.\n\nTo run a highly available setup, classes must be replicated among multiple nodes.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n## Sharding vs Replication\n\nThe motivation sections above outline when it is desirable to shard your classes across multiple nodes and when it is desirable to replicate your classes - or both. This section highlights the implications of a sharded and/or replicated setup.\n\n:::note\nAll of the scenarios below assume that - as sharding or replication is increased - the cluster size is adapted accordingly. If the number of shards or the replication factor is lower than the number of nodes in the cluster, the advantages no longer apply.*\n:::\n\n### Advantages when increasing sharding\n* Run larger datasets\n* Speed up imports.\n\nTo use multiple CPUs efficiently, create multiple shards for your collection. For the fastest imports, create multiple shards even on a single node.\n\n### Disadvantages when increasing sharding\n* Query throughput does not improve when adding more sharded nodes\n\n### Advantages when increasing replication\n* System becomes highly available\n* Increased replication leads to near-linearly increased query throughput\n\n### Disadvantages when increasing replication\n* Import speed does not improve when adding more replicated nodes\n\n### Sharding Keys (\"Partitioning Keys\")\nWeaviate uses specific characteristics of an object to decide which shard it belongs to. As of `v1.8.0`, a sharding key is always the object's UUID. The sharding algorithm is a 64bit Murmur-3 hash. Other properties and other algorithms for sharding may be added in the future.\n\nNote that in a multi-tenant collection, each tenant consists of one shard.\n\n## Shard replica movement\n\n:::info Added in `v1.32`\n:::\n\nA shard replica can be moved or copied from one node to another. This is useful when you want to balance the load across nodes or when you want to change the replication factor of a part of a collection.\n\n[See this page](/docs/deploy/configuration/replica-movement.mdx) for more details on how to move shard replicas.\n\n### Use cases for moving shard replicas\n\n1. **Load Balancing**: If certain nodes are experiencing higher loads than others, moving shard replicas can help distribute the load more evenly across the cluster.\n\n2. **Scaling**: If you need to scale your cluster (e.g., adding more nodes to handle increased load), shard replicas can be moved to the new nodes to ensure that the data is evenly distributed across the cluster.\n\n3. **Node Maintenance or Replacement**: If a node requires maintenance (e.g., hardware upgrades) or replacement, shard replicas can be moved to temporary or replacement nodes to ensure continuous availability during the maintenance window.\n\n## Cluster Resharding\n\nWeaviate supports dynamic cluster resharding, which allows administrators to redistribute data across nodes in a multi-node cluster without downtime. This feature enables you to adjust the number of shards in an existing cluster to improve performance and scalability.\n\nThe resharding process works by creating new shard mappings, migrating vector embeddings and metadata in batches, and updating the distributed hash ring to reflect the new topology.\n\n### Key capabilities\n\n* **Automatic load balancing**: The migration process includes automatic load balancing to prevent node overload during data redistribution.\n* **Configurable performance**: You can configure batch sizes and migration speed throttling to control the impact on cluster performance.\n* **Data integrity**: Real-time consistency checks ensure data integrity throughout the migration process.\n* **Rollback support**: The system supports rollback capabilities in case of migration failures.\n* **Progress monitoring**: Dedicated monitoring endpoints allow you to track resharding progress in real-time.\n\n### Resharding operation\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n- Target shard count\n- Migration speed settings\n- Validation configuration\n\nDuring the resharding process:\n- **Read operations** continue normally without interruption\n- **Write operations** are temporarily queued and replayed after shard migration completes\n\n### Typical use cases\n\nCluster resharding is particularly useful for:\n\n1. **Scaling under load**: Redistributing shards when scaling up clusters experiencing heavy load\n2. **Rebalancing after node changes**: Optimizing shard distribution after adding or removing nodes from the cluster\n3. **Performance optimization**: Adjusting shard distribution to match query performance patterns and workload characteristics\n\nFor detailed API usage and configuration options, see the [multi-node setup documentation](/docs/weaviate/manage-collections/multi-node-setup.mdx).\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate - especially when running as a cluster - is optimized to run on Kubernetes. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery. All you have to do is specify the desired node count.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable fully qualified domain name (FQDN) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which [use Raft as the consensus mechanism](./replication-architecture/cluster-architecture.md#metadata-replication-raft). It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Node affinity of shards and/or replication shards\n\nWeaviate tries to select the node with the most available disk space.\n\nThis only applies when creating a new class, rather than when adding more data to an existing single class.\n\n<details>\n  <summary>Pre-<code>v1.18.1</code> behavior</summary>\n\nIn versions `v1.8.0`-`v1.18.0`, users could not specify the node-affinity of a specific shard or replication shard.\n\nShards were assigned to 'live' nodes in a round-robin fashion starting with a random node.\n\n</details>\n\n## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* Weaviate now supports dynamic cluster scaling through the resharding feature, which allows you to redistribute data across nodes without downtime. This enables adding new nodes and rebalancing existing shards, as well as optimizing shard distribution for improved performance.\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n"
    },
    {
        "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
        "revised_doc": "---\ntitle: Multi-node setup\nsidebar_position: 5\nimage: og/docs/howto.jpg\n---\n\nimport SkipLink from \"/src/components/SkipValidationLink\";\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport FilteredTextBlock from \"@site/src/components/Documentation/FilteredTextBlock\";\nimport PyCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.py\";\nimport PyCodeV3 from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v3.py\";\nimport TSCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.ts\";\nimport TSCodeLegacy from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v2.ts\";\nimport JavaReplicationCode from '!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java';\nimport GoCode from \"!!raw-loader!/_includes/code/howto/go/docs/manage-data.classes_test.go\";\n\n## Replication settings\n\nimport RaftRFChangeWarning from \"/_includes/1-25-replication-factor.mdx\";\n\n<RaftRFChangeWarning />\n\nConfigure replication settings, such as [async replication](/deploy/configuration/replication.md#async-replication-settings) and [deletion resolution strategy](../concepts/replication-architecture/consistency.md#deletion-resolution-strategies).\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START AllReplicationSettings\"\n      endMarker=\"# END AllReplicationSettings\"\n      language=\"py\"\n      docRefs={[\n        \"weaviate.collections.classes.html#weaviate.collections.classes.config.Configure\"\n      ]}\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START AllReplicationSettings\"\n    endMarker=\"# END AllReplicationSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"class\": \"Article\",\n    \"properties\": [\n        {\n            \"dataType\": [\n                \"string\"\n            ],\n            \"description\": \"Title of the article\",\n            \"name\": \"title\"\n        }\n    ],\n    \"replicationConfig\": {\n      \"factor\": 3,\n      \"asyncEnabled\": true,\n      \"deletionStrategy\": \"TimeBasedResolution\"\n    }\n}' \\\nhttp://localhost:8080/v1/schema\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nTo use replication factors greater than one, use a [multi-node deployment](/deploy/installation-guides/docker-installation.md#multi-node-configuration).\n\nFor details on the configuration parameters, see the following:\n\n- [Replication](/weaviate/config-refs/collections.mdx#replication)\n\n</details>\n\n## Sharding settings\n\nConfigure sharding per collection.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ShardingSettings\"\n      endMarker=\"# END ShardingSettings\"\n      language=\"py\"\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START ShardingSettings\"\n    endMarker=\"# END ShardingSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"js2\" label=\"JS/TS Client v2\">\n  <FilteredTextBlock\n    text={TSCodeLegacy}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"tsv2\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nFor details on the configuration parameters, see the following:\n\n- [Sharding](/weaviate/config-refs/collections.mdx#sharding)\n\n</details>\n\n## Inspect shards (for a collection)\n\nAn index itself can be comprised of multiple shards.\n\nimport CodeSchemaShardsGet from \"/_includes/code/howto/manage-data.shards.inspect.mdx\";\n\n<CodeSchemaShardsGet />\n\n## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster resharding\n\nA multi-node Weaviate cluster can be dynamically resharded to redistribute data across nodes for improved performance and scalability. This allows administrators to adjust the number of shards in an existing cluster without downtime.\n\nThe resharding feature includes:\n\n- **Automatic load balancing**: Prevents node overload during migration\n- **Configurable migration settings**: Control batch sizes and migration speed throttling\n- **Data integrity checks**: Real-time consistency validation during migration\n- **Rollback support**: Safe recovery in case of migration failures\n- **Progress monitoring**: Track resharding status through monitoring endpoints\n\n### API endpoint\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint with parameters for:\n\n- `targetShardCount`: The desired number of shards after resharding\n- `migrationSpeed`: Controls the rate of data migration (e.g., \"slow\", \"medium\", \"fast\")\n- `validationSettings`: Configuration for consistency checks during migration\n\n### Client library support\n\nNative client library functions will be available for Python, JavaScript/TypeScript, Go, and Java. The exact syntax is being finalized.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ClusterResharding\"\n      endMarker=\"# END ClusterResharding\"\n      language=\"py\"\n    />\n  </TabItem>\n\n  <TabItem value=\"js\" label=\"JS/TS Client v3\">\n    <FilteredTextBlock\n      text={TSCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"ts\"\n    />\n  </TabItem>\n\n  <TabItem value=\"java\" label=\"Java\">\n    <FilteredTextBlock\n      text={JavaReplicationCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"java\"\n    />\n  </TabItem>\n\n  <TabItem value=\"go\" label=\"Go\">\n    <FilteredTextBlock\n      text={GoCode}\n      startMarker=\"// START ClusterResharding\"\n      endMarker=\"// END ClusterResharding\"\n      language=\"gonew\"\n    />\n  </TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"targetShardCount\": 6,\n    \"migrationSpeed\": \"medium\",\n    \"validationSettings\": {\n        \"enableConsistencyChecks\": true,\n        \"batchSize\": 1000\n    }\n}' \\\nhttp://localhost:8080/v1/cluster/resharding\n```\n\n</TabItem>\n</Tabs>\n\n### Operational behavior\n\nDuring resharding:\n\n- **Read operations**: Continue normally with no interruption\n- **Write operations**: Temporarily queued and replayed after shard migration completes\n- **Migration process**: Data is moved in configurable batches with automatic load balancing\n- **Consistency**: Real-time checks ensure data integrity throughout the process\n\n### Use cases\n\nTypical scenarios for cluster resharding include:\n\n- **Scaling under load**: Increase shard count when experiencing heavy traffic\n- **Rebalancing**: Redistribute data after adding or removing nodes\n- **Performance optimization**: Adjust shard distribution based on query patterns\n\nFor more details on cluster architecture and distributed operations, see [Multi-node concepts](../concepts/cluster.md).\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)\n\n## Questions and feedback\n\nimport DocsFeedback from \"/_includes/docs-feedback.mdx\";\n\n<DocsFeedback />\n"
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.py",
        "revised_doc": "# How-to: Manage-Data -> Classes\nimport os\n\n# ================================\n# ===== INSTANTIATION-COMMON =====\n# ================================\n\nimport weaviate\n\n# Instantiate the client with the OpenAI API key\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\n            \"OPENAI_API_KEY\"\n        ]  # Replace with your inference API key\n    }\n)\n\n# ================================\n# ===== CREATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START BasicCreateCollection\nclient.collections.create(\"Article\")\n# END BasicCreateCollection\n\n# Test\nassert client.collections.exists(\"Article\")\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH PROPERTIES =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START CreateCollectionWithProperties\nfrom weaviate.classes.config import Property, DataType\n\n# Note that you can use `client.collections.create_from_dict()` to create a collection from a v3-client-style JSON object\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END CreateCollectionWithProperties\n\n# Test\narticles = client.collections.use(\"Article\")\nassert client.collections.exists(\"Article\")\nassert len(articles.config.get().properties) == 2\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH VECTORIZER =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Vectorizer\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-end\n    properties=[  # properties configuration is optional\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END Vectorizer\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH NAMED VECTORS =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"ArticleNV\")\n\n# START BasicNamedVectors\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"ArticleNV\",\n    # highlight-start\n    vector_config=[\n        # Set a named vector with the \"text2vec-cohere\" vectorizer\n        Configure.Vectors.text2vec_cohere(\n            name=\"title\",\n            source_properties=[\"title\"],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set another named vector with the \"text2vec-openai\" vectorizer\n        Configure.Vectors.text2vec_openai(\n            name=\"title_country\",\n            source_properties=[\n                \"title\",\n                \"country\",\n            ],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set a named vector for your own uploaded vectors\n        Configure.Vectors.self_provided(\n            name=\"custom_vector\",\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n    ],\n    # highlight-end\n    properties=[  # Define properties\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"country\", data_type=DataType.TEXT),\n    ],\n)\n# END BasicNamedVectors\n\n# Test\ncollection = client.collections.use(\"ArticleNV\")\nconfig = collection.config.get()\n\nassertion_dicts = {\n    \"title\": [\"title\"],\n    \"title_country\": [\"title\", \"country\"],\n    \"custom_vector\": None,\n}\nfor k, v in config.vector_config.items():\n    assert (\n        v.vectorizer.source_properties == assertion_dicts[k]\n    )  # Test that the source properties are correctly set\n\n# ===========================\n# ===== SET VECTOR INDEX TYPE =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexType\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(),  # Use the HNSW index\n        # vector_index_config=Configure.VectorIndex.flat(),  # Use the FLAT index\n        # vector_index_config=Configure.VectorIndex.dynamic(),  # Use the DYNAMIC index\n        # highlight-end\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END SetVectorIndexType\n\n# Test\nfrom weaviate.collections.classes.config import _VectorIndexConfigHNSW\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n# ===========================\n# ===== SET VECTOR INDEX PARAMETERS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexParams\nfrom weaviate.classes.config import (\n    Configure,\n    Property,\n    DataType,\n    VectorDistances,\n    VectorFilterStrategy,\n)\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            ef_construction=300,\n            distance_metric=VectorDistances.COSINE,\n            filter_strategy=VectorFilterStrategy.SWEEPING,  # or ACORN (Available from Weaviate v1.27.0)\n        ),\n        # highlight-end\n    ),\n)\n# END SetVectorIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.filter_strategy == \"sweeping\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n\n# ===================================================================\n# ===== CREATE A COLLECTION WITH CUSTOM INVERTED INDEX SETTINGS =====\n# ===================================================================\n\nclient.collections.delete(\"Article\")\n\n# START SetInvertedIndexParams\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # Additional settings not shown\n    properties=[  # properties configuration is optional\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk_number\",\n            data_type=DataType.INT,\n            # highlight-start\n            index_range_filters=True,\n            # highlight-end\n        ),\n    ],\n    # highlight-start\n    inverted_index_config=Configure.inverted_index(  # Optional\n        bm25_b=0.7,\n        bm25_k1=1.25,\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True,\n    ),\n    # highlight-end\n)\n# END SetInvertedIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.inverted_index_config.bm25.b == 0.7\nassert config.inverted_index_config.bm25.k1 == 1.25\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetReranker\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.cohere(),\n    # highlight-end\n)\n# END SetReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.voyageai(),\n    # highlight-end\n)\n\n# START UpdateReranker\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    reranker_config=Reconfigure.Reranker.cohere()  # Update the reranker module\n    # highlight-end\n)\n# END UpdateReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetGenerative\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4o\"  # set your generative model (optional parameter)\n    ),\n    # highlight-end\n)\n# END SetGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-openai\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(),\n    # highlight-end\n)\n\n# START UpdateGenerative\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    generative_config=Reconfigure.Generative.cohere()  # Update the generative module\n    # highlight-end\n)\n# END UpdateGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ======================================================\n# ===== MULTI-VECTOR EMBEDDINGS (ColBERT, ColPali)\n# ======================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorCollection\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        # The factory function will automatically enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n        ),\n        # highlight-end\n        # Example 2 - User-provided multi-vector representations\n        # Must explicitly enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.self_provided(\n            # highlight-end\n            name=\"custom_multi_vector\",\n        ),\n    ],\n    properties=[Property(name=\"text\", data_type=DataType.TEXT)],\n    # Additional parameters not shown\n)\n# END MultiValueVectorCollection\n\n# ==========================================\n# ===== MULTI-VECTOR EMBEDDINGS MUVERA\n# ==========================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorMuvera\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(\n                # Optional parameters for tuning MUVERA\n                # ksim: 4,\n                # dprojections: 16,\n                # repetitions: 20,\n            ),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorMuvera\n\n# ================================================\n# ===== MULTI-VECTOR EMBEDDINGS QUANTIZATION\n# ================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorPQ\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorPQ\n\n# ===========================\n# ===== MODULE SETTINGS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ModuleSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_cohere(\n        model=\"embed-multilingual-v2.0\", vectorize_collection_name=True\n    ),\n    # highlight-end\n)\n# END ModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"default\"].vectorizer.model[\"model\"] == \"embed-multilingual-v2.0\"\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START PropModuleSettings\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            vectorize_property_name=True,  # Use \"title\" as part of the value to vectorize\n            tokenization=Tokenization.LOWERCASE,  # Use \"lowecase\" tokenization\n            description=\"The title of the article.\",  # Optional description\n            # highlight-end\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            skip_vectorization=True,  # Don't vectorize this property\n            tokenization=Tokenization.WHITESPACE,  # Use \"whitespace\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END PropModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nfor p in config.properties:\n    if p.name == \"title\":\n        assert p.tokenization.name == \"LOWERCASE\"\n    elif p.name == \"body\":\n        assert p.tokenization.name == \"WHITESPACE\"\n\n\n# ====================================\n# ======= TRIGRAM TOKENIZATION =======\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START TrigramTokenization\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            tokenization=Tokenization.TRIGRAM,  # Use \"trigram\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END TrigramTokenization\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# START AddNamedVectors\nfrom weaviate.classes.config import Configure\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_vector(\n    vector_config=Configure.Vectors.text2vec_cohere(\n        name=\"body_vector\",\n        source_properties=[\"body\"],\n    )\n)\n# END AddNamedVectors\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"body_vector\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.properties[0].tokenization.name == \"TRIGRAM\"\n\n\n# ===========================\n# ===== DISTANCE METRIC =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START DistanceMetric\nfrom weaviate.classes.config import Configure, VectorDistances\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            distance_metric=VectorDistances.COSINE\n        ),\n        # highlight-end\n    )\n)\n# END DistanceMetric\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.distance_metric.value == \"cosine\"\n\n# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()\n\n# =======================\n# ===== REPLICATION =====\n# =======================\n\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# clean slate\nclient.collections.delete(\"Article\")\n# START ReplicationSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n    ),\n    # highlight-end\n)\n# END ReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.factor == 3\n\n# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()\n\n# =======================\n# ===== REPLICATION WITH ASYNC REPAIR ====\n# =======================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AsyncRepair\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,\n    ),\n    # highlight-end\n)\n# END AsyncRepair\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n# assert config.replication_config.factor == 3   #ASYNC NEEDS TEST\n\n# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()\n\n# ==============================================\n# ===== ALL REPLICATION SETTINGS\n# ==============================================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AllReplicationSettings\nfrom weaviate.classes.config import Configure, ReplicationDeletionStrategy\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,  # Enable asynchronous repair\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION,  # Added in v1.28; Set the deletion conflict resolution strategy\n    ),\n    # highlight-end\n)\n# END AllReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.async_enabled == True\nassert (\n    config.replication_config.deletion_strategy\n    == ReplicationDeletionStrategy.TIME_BASED_RESOLUTION\n)\n\n# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()\n\n# ====================\n# ===== SHARDING =====\n# ====================\n\nclient = weaviate.connect_to_local()\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ShardingSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    sharding_config=Configure.sharding(\n        virtual_per_physical=128,\n        desired_count=1,\n        desired_virtual_count=128,\n    ),\n    # highlight-end\n)\n# END ShardingSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.sharding_config.virtual_per_physical == 128\nassert config.sharding_config.desired_count == 1\nassert config.sharding_config.desired_virtual_count == 128\n\n# =========================\n# ===== MULTI-TENANCY =====\n# =========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Multi-tenancy\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    multi_tenancy_config=Configure.multi_tenancy(True),\n    # highlight-end\n)\n# END Multi-tenancy\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.multi_tenancy_config.enabled == True\n\n# ==========================\n# ===== ADD A PROPERTY =====\n# ==========================\n\n# START AddProp\nfrom weaviate.classes.config import Property, DataType\n\n# Get the Article collection object\narticles = client.collections.use(\"Article\")\n\n# Add a new property\narticles.config.add_property(\n    # highlight-start\n    prop=Property(name=\"body\", data_type=DataType.TEXT)\n    # highlight-end\n)\n# END AddProp\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert len(config.properties) == 1\nassert config.properties[0].name == \"body\"\n\n# ================================\n# ===== CHECK IF A COLLECTION EXISTS =====\n# ================================\n\n# START CheckIfExists\nexists = client.collections.exists(\"Article\")  # Returns a boolean\n# END CheckIfExists\n\n# ================================\n# ===== READ A COLLECTION =====\n# ================================\n\n# START ReadOneCollection\narticles = client.collections.use(\"Article\")\narticles_config = articles.config.get()\n\nprint(articles_config)\n# END ReadOneCollection\n\nassert articles_config.name == \"Article\"\n\n\n# ================================\n# ===== READ ALL COLLECTIONS =====\n# ================================\n\n# START ReadAllCollections\nresponse = client.collections.list_all(simple=False)\n\nprint(response)\n# END ReadAllCollections\n\nassert type(response) == dict\nassert \"Article\" in response\n\n\n# ================================\n# ===== UPDATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# Define and create a collection\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    name=\"Article\",\n    inverted_index_config=Configure.inverted_index(bm25_b=0.7, bm25_k1=1.2),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n        ),\n    ],\n)\nold_config = articles.config.get()\n\n\n# Create an object to check that it remains mutable\nfor _ in range(5):\n    articles.data.insert({\"title\": \"A grand day out.\"})\n\n\n# START UpdateCollection\nfrom weaviate.classes.config import (\n    Reconfigure,\n    VectorFilterStrategy,\n    ReplicationDeletionStrategy,\n)\n\narticles = client.collections.use(\"Article\")\n\n# Update the collection definition\narticles.config.update(\n    description=\"An updated collection description.\",\n    property_descriptions={\n        \"title\": \"The updated title description for article\",\n    },  # Available from Weaviate v1.31.0\n    inverted_index_config=Reconfigure.inverted_index(bm25_k1=1.5),\n    vector_config=Reconfigure.Vectors.update(\n        name=\"default\",\n        vector_index_config=Reconfigure.VectorIndex.hnsw(\n            filter_strategy=VectorFilterStrategy.ACORN  # Available from Weaviate v1.27.0\n        ),\n    ),\n    replication_config=Reconfigure.replication(\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION  # Available from Weaviate v1.28.0\n    ),\n)\n# END UpdateCollection\n\nnew_config = articles.config.get()\n\nassert old_config.inverted_index_config.bm25.k1 == 1.2\nassert new_config.inverted_index_config.bm25.k1 == 1.5\n\nproperty_descriptions = {prop.name: prop.description for prop in new_config.properties}\nassert property_descriptions[\"title\"] == \"The updated title description for article\"\n\n# ================================\n# ===== DELETE A COLLECTION =====\n# ================================\n\ncollection_name = \"Article\"\n\n# START DeleteCollection\n# collection_name can be a string (\"Article\") or a list of strings ([\"Article\", \"Category\"])\nclient.collections.delete(\n    collection_name\n)  # THIS WILL DELETE THE SPECIFIED COLLECTION(S) AND THEIR OBJECTS\n\n# Note: you can also delete all collections in the Weaviate instance with:\n# client.collections.delete_all()\n# END DeleteCollection\n\n# ========================================\n# AddProperty\n# ========================================\n\nclient.collections.create(name=\"Article\")\n\n# START AddProperty\nfrom weaviate.classes.config import Property, DataType\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_property(Property(name=\"onHomepage\", data_type=DataType.BOOL))\n# END AddProperty\n\n# ========================================\n# InspectCollectionShards\n# ========================================\n\n# START InspectCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.get_shards()\n# highlight-end\nprint(article_shards)\n# END InspectCollectionShards\n\n\n# ========================================\n# UpdateCollectionShards\n# ========================================\n\nshards = articles.config.get_shards()\nshard_names = [s.name for s in shards]\n\n# START UpdateCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.update_shards(\n    status=\"READY\",\n    shard_names=shard_names,  # The names (List[str]) of the shard to update (or a shard name)\n)\n# highlight-end\n\nprint(article_shards)\n# END UpdateCollectionShards\n\n\n# ====================================================\n# ===== CLUSTER RESHARDING\n# ====================================================\n\n# START ClusterResharding\n# Doc writer / engineer TODO: New code example to go here\n# Trigger cluster resharding with target shard count and migration settings\n# cluster_resharding_result = client.cluster.reshard(\n#     target_shard_count=6,\n#     migration_speed=\"medium\",  # \"slow\", \"medium\", \"fast\"\n#     validation_settings={\n#         \"enable_consistency_checks\": True,\n#         \"batch_size\": 1000\n#     }\n# )\n\n# Monitor resharding progress\n# resharding_status = client.cluster.resharding_status()\n# print(f\"Resharding progress: {resharding_status['progress']}%\")\n# print(f\"Status: {resharding_status['status']}\")\n\n# Handle potential rollback\n# if resharding_status['status'] == 'failed':\n#     rollback_result = client.cluster.rollback_resharding()\n#     print(f\"Rollback successful: {rollback_result['success']}\")\n# END ClusterResharding\n\nclient.close()\n"
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.ts",
        "revised_doc": "// How-to: Manage-data -> Classes - TypeScript examples\n// run with: node --loader=ts-node/esm FILENAME.ts\nimport assert from 'assert';\n\n// ================================\n// ===== INSTANTIATION-COMMON =====\n// ================================\nimport weaviate, { WeaviateClient, vectorIndex } from 'weaviate-client';\nimport { reranker, vectors, generative, dataType, tokenization, reconfigure, vectorDistances } from 'weaviate-client';\n\nconst weaviateURL = process.env.WEAVIATE_URL as string\nconst weaviateKey = process.env.WEAVIATE_API_KEY as string\nconst openaiKey = process.env.OPENAI_API_KEY as string\n\nconst client: WeaviateClient = await weaviate.connectToLocal({headers: {\n     'X-OpenAI-Api-Key': openaiKey as string,  // Replace with your inference API key\n   }\n }\n)\n\nconst collectionName = 'Article'\nlet result\n\n\n/*\n// START UpdateCollection // START UpdateReranker // START UpdateGenerative\nimport { reconfigure } from 'weaviate-client';\n\n// END UpdateCollection // END UpdateReranker // END UpdateGenerative\n*/\n\n// START UpdateCollection // START ReadOneCollection\nlet articles = client.collections.use('Article')\n// END UpdateCollection // END ReadOneCollection\n\n// ================================\n// ===== CREATE A CLASS =====\n// ================================\n\n// Clean slate\ntry {\n  await client.collections.delete(collectionName)\n\n} catch (e) {\n  // ignore error if class doesn't exist\n}\n{\n// START BasicCreateCollection\nconst newCollection = await client.collections.create({\n  name: 'Article'\n})\n\n// The returned value is the full collection definition, showing all defaults\nconsole.log(JSON.stringify(newCollection, null, 2));\n// END BasicCreateCollection\n\n// Test\n// (client.collections.use('ArticleNV').config.get()).vectorizer.body.vectorizer\nresult = client.collections.use(collectionName).config.get()\n\nconsole.assert('replication' in result);\n}\n// ====================================\n// ===== CREATE A CLASS WITH PROPERTIES\n// ====================================\n\n// Clean slate\ntry {\n  await client.collections.delete(collectionName)\n} catch (e) {\n  // ignore error if class doesn't exist\n}\n\n/*\n// START CreateCollectionWithProperties\nimport { dataType } from 'weaviate-client';\n\n// END CreateCollectionWithProperties\n*/\n\n// START CreateCollectionWithProperties\nawait client.collections.create({\n  name: 'Article',\n  properties: [\n    {\n      name: 'title',\n      dataType: dataType.TEXT,\n    },\n    {\n      name: 'body',\n      dataType: dataType.TEXT,\n    },\n  ],\n})\n// END CreateCollectionWithProperties\n\n// ================================\n// ===== CHECK IF A COLLECTION EXISTS =====\n// ================================\n\n// START CheckIfExists\nvar exists = client.collections.exists(\"Article\")  // Returns a boolean\n// END CheckIfExists\n\n// ================================\n// ===== READ A COLLECTION =====\n// ================================\n\narticles = client.collections.use('Article')\n// START ReadOneCollection\n// highlight-start\nconst collectionConfig = await articles.config.get()\n// highlight-end\nconsole.log(collectionConfig)\n// END ReadOneCollection\n\n// ==================================================\n// ===== CREATE A COLLECTION WITH NAMED VECTORS =====\n// ==================================================\n\n/*\n// START BasicNamedVectors\nimport { vectors, dataType } from 'weaviate-client';\n\n// END BasicNamedVectors\n*/\n\n// START BasicNamedVectors\nawait client.collections.create({\n  name: 'ArticleNV',\n\n  // highlight-start\n  vectorizers: [\n    // Set a named vector with the \"text2vec-cohere\" vectorizer\n    vectors.text2VecCohere({\n      name: 'title',\n      sourceProperties: ['title'],                      // (Optional) Set the source property(ies)\n      vectorIndexConfig: configure.vectorIndex.hnsw()   // (Optional) Set the vector index configuration\n    }),\n    // Set a named vector with the \"text2vec-openai\" vectorizer\n    vectors.text2VecOpenAI({\n      name: 'title_country',\n      sourceProperties: ['title','country'],            // (Optional) Set the source property(ies)\n      vectorIndexConfig: configure.vectorIndex.hnsw()   // (Optional) Set the vector index configuration\n    }),\n    // Set a named vector for your own uploaded vectors\n    vectors.selfProvided({\n      name: 'custom_vector',\n      vectorIndexConfig: configure.vectorIndex.hnsw()   // (Optional) Set the vector index configuration\n    })\n  ],\n  // highlight-end\n\n  properties: [\n    { name: 'title', dataType: dataType.TEXT },\n    { name: 'country', dataType: dataType.TEXT },\n  ],\n})\n// END BasicNamedVectors\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\n// TODO - fix this test\n// assert.equal(\n//   result.vectorizer.title.properties,\n//   'title'\n// );\n// assert.equal(\n//   result.vectorizer.body.properties,\n//   'body'\n// );\n\n// Delete the class to recreate it\nawait client.collections.delete('ArticleNV')\n\n// ===============================================\n// ===== CREATE A COLLECTION WITH VECTORIZER =====\n// ===============================================\n\n/*\n// START Vectorizer\nimport { vectors, dataType } from 'weaviate-client';\n\n// END Vectorizer\n*/\n\n// START Vectorizer\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  vectorizers: vectors.text2VecOpenAI(),\n  // highlight-end\n  properties: [\n    { name: 'title', dataType: dataType.TEXT },\n    { name: 'body', dataType: dataType.TEXT },\n  ],\n})\n// END Vectorizer\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.vectorizer.name, 'text2vec-openai');\nassert.equal(result.properties.length, 2);\n\n// Delete the class to recreate it\nawait client.collections.delete('Article')\n\n// ===========================\n// ===== SetVectorIndexType =====\n// ===========================\n\n/*\n// START SetVectorIndexType\nimport { vectors, dataType, configure } from 'weaviate-client';\n\n// END SetVectorIndexType\n*/\n\n// START SetVectorIndexType\nawait client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecOpenAI({\n    // highlight-start\n    vectorIndexConfig: configure.vectorIndex.hnsw(),  // Use HNSW\n    // vectorIndexConfig: configure.vectorIndex.flat(),  // Use Flat\n    // vectorIndexConfig: configure.vectorIndex.dynamic(),  // Use Dynamic\n    // highlight-end\n  }),\n  properties: [\n    { name: 'title', dataType: dataType.TEXT },\n    { name: 'body', dataType: dataType.TEXT },\n  ],\n})\n// END SetVectorIndexType\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.vectorizer.name, 'text2vec-openai');\nassert.equal(result.vectorIndexType, 'hnsw');\nassert.equal(result.properties.length, 2);\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// ===========================\n// ===== SetVectorIndexParams =====\n// ===========================\n\n/*\n// START SetVectorIndexParams\nimport { configure, vectors } from 'weaviate-client';\n\n// END SetVectorIndexParams\n*/\n\n// START SetVectorIndexParams\nawait client.collections.create({\n  name: 'Article',\n  // Additional configuration not shown\n  vectorizers: vectors.text2VecCohere({\n    // highlight-start\n    vectorIndexConfig: configure.vectorIndex.flat({\n      quantizer: configure.vectorIndex.quantizer.bq({\n        rescoreLimit: 200,\n        cache: true\n      }),\n      vectorCacheMaxObjects: 100000\n    })\n    // highlight-end\n  })\n})\n// END SetVectorIndexParams\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.vectorizer.name, 'text2vec-openai');\nassert.equal(result.vectorIndexType, 'flat');\nassert.equal(result.properties.length, 2);\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// ===========================\n// ===== MODULE SETTINGS =====\n// ===========================\n\n/*\n// START ModuleSettings\nimport { vectors } from 'weaviate-client';\n\n// END ModuleSettings\n*/\n\n\n// START ModuleSettings\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  vectorizers: vectors.text2VecCohere({\n    model: 'embed-multilingual-v2.0',\n  }),\n  // highlight-end\n})\n// END ModuleSettings\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.vectorizer.name, 'text2vec-cohere');\nassert.equal(\n  result.vectorizer.default.vectorizer.config.model,\n  'embed-multilingual-v2.0'\n);\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// ====================================\n// ===== MODULE SETTINGS PROPERTY =====\n// ====================================\n\n/*\n// START PropModuleSettings\nimport { vectors, dataType, tokenization } from 'weaviate-client';\n\n// END PropModuleSettings\n*/\n{\n// START PropModuleSettings\nconst newCollection = await client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecHuggingFace(),\n  properties: [\n    {\n      name: 'title',\n      dataType: dataType.TEXT,\n      // highlight-start\n      vectorizePropertyName: true,\n      tokenization: tokenization.LOWERCASE // or 'lowercase'\n      // highlight-end\n    },\n    {\n      name: 'body',\n      dataType: dataType.TEXT,\n      // highlight-start\n      skipVectorization: true,\n      tokenization: tokenization.WHITESPACE // or 'whitespace'\n      // highlight-end\n    },\n  ],\n})\n// END PropModuleSettings\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// ====================================\n// ======= TRIGRAM TOKENIZATION =======\n// ====================================\n\n/*\n// START TrigramTokenization\nimport { vectors, dataType, tokenization } from 'weaviate-client';\n\n// END TrigramTokenization\n*/\n{\n// START TrigramTokenization\nconst newCollection = await client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecHuggingFace(),\n  properties: [\n    {\n      name: 'title',\n      dataType: dataType.TEXT,\n      // highlight-start\n      tokenization: tokenization.TRIGRAM  // Use \"trigram\" tokenization\n      // highlight-end\n    },\n  ],\n})\n// END TrigramTokenization\n\n// Test vectorizeCollectionName\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.vectorizer.name, 'text2vec-cohere');\nassert.equal(\n  result.vectorizer.default.vectorizer.config.vectorizeCollectionName,\n  'true'\n);\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n}\n\n// ====================================\n// ===== MODULE SETTINGS PROPERTY =====\n// ====================================\n\n// START AddNamedVectors\nawait articles.config.addVector(\n    vectors.text2VecCohere({\n        name: \"body_vector\",\n        sourceProperties: [\"body\"],\n    })\n)\n// END AddNamedVectors\n\n// Test\nconst testCollection = client.collections.use(\"Article\")\nconst testConfig = await testCollection.config.get()\n\nassert.equal(testConfig.vectorizers[\"body_vector\"].vectorizer.name, \"text2vec-cohere\")\nfor (const p of testConfig.properties) {\n    if (p.name == \"title\") {\n        assert.equal(p.tokenization, \"lowercase\")\n    }\n    else if (p.name == \"body\") {\n        assert.equal(p.tokenization, \"whitespace\")\n    }\n\n}\n\n\n// ===========================\n// ===== DISTANCE METRIC =====\n// ===========================\n\n/*\n// START DistanceMetric\nimport { configure, vectors, vectorDistances } from 'weaviate-client';\n\n// END DistanceMetric\n*/\n\n// START DistanceMetric\nawait client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecOllama({\n    // highlight-start\n    vectorIndexConfig: configure.vectorIndex.hnsw({\n      distanceMetric: vectorDistances.COSINE // or 'cosine'\n    })\n    // highlight-end\n  })\n})\n// END DistanceMetric\n\n// Test\nresult = client.collections.use(collectionName).config.get()\n\nassert.equal(result.vectorizer.default.indexConfig.distance, 'cosine');\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// ===================================================================\n// ===== CREATE A COLLECTION WITH CUSTOM INVERTED INDEX SETTINGS =====\n// ===================================================================\n\n/*\n// START SetInvertedIndexParams\nimport { dataType } from 'weaviate-client';\n\n// END SetInvertedIndexParams\n*/\n\n// START SetInvertedIndexParams\nawait client.collections.create({\n  name: 'Article',\n  properties: [\n    {\n      name: 'title',\n      dataType: dataType.TEXT,\n      // highlight-start\n      indexFilterable: true,\n      indexSearchable: true,\n      // highlight-end\n    },\n    {\n      name: 'chunk',\n      dataType: dataType.TEXT,\n      // highlight-start\n      indexFilterable: true,\n      indexSearchable: true,\n      // highlight-end\n    },\n    {\n      name: 'chunk_no',\n      dataType: dataType.INT,\n      // highlight-start\n      indexRangeFilters: true,\n      // highlight-end\n    },\n  ],\n  // highlight-start\n  invertedIndex: {\n    bm25: {\n      b: 0.7,\n      k1: 1.25\n    },\n    indexNullState: true,\n    indexPropertyLength: true,\n    indexTimestamps: true\n  }\n  // highlight-end\n})\n// END SetInvertedIndexParams\n\n// Test\nassert.equal(result.vectorizer, 'text2vec-huggingface');\nassert.equal(\n  result.properties[0].moduleConfig['text2vec-huggingface'][\n    'vectorizePropertyName'\n  ],\n  false\n);\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n\n// ===============================================\n// ===== CREATE A COLLECTION WITH A RERANKER MODULE =====\n// ===============================================\n/*\n// START SetReranker\nimport { vectors, reranker } from 'weaviate-client';\n\n// END SetReranker\n/*\n// START SetReranker\nawait client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecOpenAI(),\n  // highlight-start\n  reranker: reranker.cohere(),\n  // highlight-end\n})\n// END SetReranker\n\n// Test\nObject.keys(result['moduleConfig']).includes('reranker-cohere');\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n\n// ===============================================\n// ===== CREATE A COLLECTION WITH A GENERATIVE MODULE =====\n// ===============================================\n\n/*\n// START SetGenerative\nimport { vectors, generative } from 'weaviate-client';\n\n// END SetGenerative\n*/\n\n// START SetGenerative\nawait client.collections.create({\n  name: 'Article',\n  vectorizers: vectors.text2VecOpenAI(),\n  // highlight-start\n  generative: generative.openAI({\n    model: \"gpt-4o\"  // set your generative model (optional parameter)\n  }),\n  // highlight-end\n})\n// END SetGenerative\n\n// Test\nObject.keys(result['moduleConfig']).includes('generative-openai');\n\n// Delete the class to recreate it\nawait client.collections.delete(collectionName)\n\n// =======================\n// ===== REPLICATION =====\n// =======================\n\n/*\n// START ReplicationSettings\nimport { configure } from 'weaviate-client';\n\n// END ReplicationSettings\n*/\n\n// START ReplicationSettings\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  replication: configure.replication({\n    factor: 3\n  }),\n  // highlight-end\n})\n// END ReplicationSettings\n\n// Test\nassert.equal(result.replicationConfig.factor, 3);\n\n\n// =======================\n// ===== Async Repair ====\n// =======================\n\n/*\n// START AsyncRepair\nimport { configure } from 'weaviate-client';\n\n// END AsyncRepair\n*/\n\n// START AsyncRepair\nawait client.collections.create({\n name: 'Article',\n // highlight-start\n replication: configure.replication({\n   factor: 3,\n   asyncEnabled: true,\n }),\n // highlight-end\n})\n// END AsyncRepair\n\n// Test\n// TODO NEEDS TEST assert.equal(result.replicationConfig.factor, 3);\n\n// =======================\n// ===== All replication settings\n// =======================\n\n/*\n// START AllReplicationSettings\nimport { configure } from 'weaviate-client';\n\n// END AllReplicationSettings\n*/\n\n// START AllReplicationSettings\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  replication: configure.replication({\n    factor: 3,\n    asyncEnabled: true,\n    deletionStrategy: 'TimeBasedResolution'  // Available from Weaviate v1.28.0\n  }),\n  // highlight-end\n })\n // END AllReplicationSettings\n\n // Test\n // TODO NEEDS TEST assert.equal(result.replicationConfig.factor, 3);\n\n// ====================\n// ===== SHARDING =====\n// ====================\n\n/*\n// START ShardingSettings\nimport { configure } from 'weaviate-client';\n\n// END ShardingSettings\n*/\n\n// START ShardingSettings\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  sharding: configure.sharding({\n    virtualPerPhysical: 128,\n    desiredCount: 1,\n    desiredVirtualCount: 128,\n  })\n  // highlight-end\n})\n// END ShardingSettings\n\n// Test\nassert.equal(result.shardingConfig.virtual_per_physical, 128);\nassert.equal(result.shardingConfig.desired_count, 1);\nassert.equal(result.shardingConfig.actual_count, 1);\nassert.equal(result.shardingConfig.desired_virtual_count, 128);\nassert.equal(result.shardingConfig.actual_virtual_count, 128);\n\n// =========================\n// ===== MULTI-TENANCY =====\n// =========================\n\n// START Multi-tenancy\nawait client.collections.create({\n  name: 'Article',\n  // highlight-start\n  multiTenancy: { enabled: true }\n  // multiTenancy: configure.multiTenancy({ enabled: true }) // alternatively use helper function\n  // highlight-end\n})\n// END Multi-tenancy\n\n// ==========================\n// ===== ADD A PROPERTY =====\n// ==========================\n\n// // START AddProp\n// const prop = {\n//   name: 'body',\n//   dataType: ['text'],\n// };\n\n// const resultProp = await client.schema\n//   .propertyCreator()\n//   .withClassName('Article')\n//   .withProperty(prop)\n//   .do();\n\n// // The returned value is full property definition\n// console.log(JSON.stringify(resultProp, null, 2));\n// // END AddProp\n\n// // Test\n// assert.equal(resultProp.name, 'body');\n\n// ================================\n// ===== READ A CLASS =====\n// ================================\n\n// START ReadAllCollections\nconst allCollections = await client.collections.listAll()\nconsole.log(JSON.stringify(allCollections, null, 2));\n// END ReadAllCollections\n\n// ================================\n// ===== UPDATE A COLLECTION =====\n// ================================\n\narticles = client.collections.use('Article')\n\n\n// START UpdateCollection\n\n// highlight-start\nawait articles.config.update({\n  invertedIndex: reconfigure.invertedIndex({\n    bm25k1: 1.5 // Change the k1 parameter from 1.2\n  }),\n    vectorizers: reconfigure.vectors.update({\n      vectorIndexConfig: reconfigure.vectorIndex.hnsw({\n        quantizer: reconfigure.vectorIndex.quantizer.pq(),\n        ef: 4,\n        filterStrategy: 'acorn',  // Available from Weaviate v1.27.0\n      }),\n\n  })\n})\n// highlight-end\n// END UpdateCollection\n\n// ===============================================\n// ===== UPDATE A COLLECTION'S RERANKER MODULE =====\n// ===============================================\n\nclient.collections.delete(\"Article\")\n\n\nawait client.collections.create({\n    name: \"Article\",\n    vectorizers: vectors.text2VecOpenAI(),\n    // highlight-start\n    reranker: configure.reranker.voyageAI()\n    // highlight-end\n})\n\n// START UpdateReranker\nconst collection = client.collections.use('Article')\n\nawait collection.config.update({\n    // highlight-start\n    reranker: reconfigure.reranker.cohere()  // Update the reranker module\n    // highlight-end\n})\n// END UpdateReranker\n\n// Test\nlet config = await collection.config.get()\nassert.equal(config.reranker?.name,\"reranker-cohere\")\n\n// Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n// ==========================================\n// ===== MULTI-VECTOR EMBEDDINGS MUVERA\n// ==========================================\n\n// Clean slate\nawait client.collections.delete(\"DemoCollection\")\n\n// START MultiValueVectorMuvera\nimport { configure } from 'weaviate-client';\n\nawait client.collections.create({\n    name: \"DemoCollection\",\n    vectorizers: [\n        // Example 1 - Use a model integration\n        configure.multiVectors.text2VecJinaAI({\n            name: \"jina_colbert\",\n            sourceProperties: [\"text\"],\n            // highlight-start\n            encoding: configure.vectorIndex.multiVector.encoding.muvera({\n                // Optional parameters for tuning MUVERA\n                ksim: 4,\n                dprojections: 16,\n                repetitions: 20,\n        }),\n            // highlight-end\n}),\n        // Example 2 - User-provided multi-vector representations\n        configure.multiVectors.selfProvided({\n            name: \"custom_multi_vector\",\n            encoding: configure.vectorIndex.multiVector.encoding.muvera(),\n}),\n    ],\n    // Additional parameters not shown\n})\n// END MultiValueVectorMuvera\n\n\n// ===============================================\n// ===== UPDATE A COLLECTION'S GENERATIVE MODULE =====\n// ===============================================\n\nclient.collections.delete(\"Article\")\n\nclient.collections.create({\n    name: \"Article\",\n    vectorizers: configure.vectors.text2VecOpenAI(),\n    // highlight-start\n    generative: configure.generative.openAI()\n    // highlight-end\n})\n\n// START UpdateGenerative\nconst collection = client.collections.use(\"Article\")\n\nawait collection.config.update({\n    // highlight-start\n    generative: weaviate.reconfigure.generative.cohere()  // Update the generative module\n    // highlight-end\n})\n// END UpdateGenerative\n\n// Test\nlet config = await collection.config.get()\nassert.equal(config.generative?.name, \"generative-cohere\")\n\n// Delete the collection to recreate it\nclient.collections.delete('Article')\n\n// ======================================================\n// ===== MULTI-VECTOR EMBEDDINGS (ColBERT, ColPali)\n// ======================================================\n\n// Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n// START MultiValueVectorCollection\nawait client.collections.create({\n    name: \"DemoCollection\",\n    vectorizers: [\n        // Example 1 - Use a model integration\n        // The factory function will automatically enable multi-vector support for the HNSW index\n        // highlight-start\n        configure.multiVectors.text2VecJinaAI({\n            name: \"jina_colbert\",\n            sourceProperties: [\"text\"],\n        }),\n        // highlight-end\n        // Example 2 - User-provided multi-vector representations\n        // Must explicitly enable multi-vector support for the HNSW index\n        // highlight-start\n        configure.multiVectors.selfProvided({\n            // highlight-end\n            name: \"custom_multi_vector\",\n        }),\n    ],\n    properties: [{ name: \"text\", dataType: dataType.TEXT }],\n    // Additional parameters not shown\n})\n// END MultiValueVectorCollection\n\n// ====================================================\n// ===== CLUSTER RESHARDING\n// ====================================================\n\n// START ClusterResharding\n// Doc writer / engineer TODO: New code example to go here\n// Trigger cluster resharding with target shard count and migration settings\n// const clusterReshardingResult = await client.cluster.reshard({\n//     targetShardCount: 6,\n//     migrationSpeed: 'medium', // 'slow', 'medium', 'fast'\n//     validationSettings: {\n//         enableConsistencyChecks: true,\n//         batchSize: 1000\n//     }\n// });\n\n// Monitor resharding progress\n// const reshardingStatus = await client.cluster.reshardingStatus();\n// console.log(`Resharding progress: ${reshardingStatus.progress}%`);\n// console.log(`Status: ${reshardingStatus.status}`);\n\n// Handle potential rollback\n// if (reshardingStatus.status === 'failed') {\n//     const rollbackResult = await client.cluster.rollbackResharding();\n//     console.log(`Rollback successful: ${rollbackResult.success}`);\n// }\n// END ClusterResharding\n"
    },
    {
        "path": "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java",
        "revised_doc": "// How-to: Manage-Data -> Classes\npackage io.weaviate.docs;\n\nimport com.google.gson.GsonBuilder;\nimport io.weaviate.client.Config;\nimport io.weaviate.client.WeaviateClient;\nimport io.weaviate.client.base.Result;\nimport io.weaviate.client.v1.misc.model.ReplicationConfig;\nimport io.weaviate.client.v1.misc.model.ShardingConfig;\nimport io.weaviate.client.v1.schema.model.Schema;\nimport io.weaviate.client.v1.schema.model.WeaviateClass;\nimport io.weaviate.client.v1.misc.model.BM25Config;\nimport io.weaviate.client.v1.misc.model.InvertedIndexConfig;\nimport io.weaviate.client.v1.misc.model.VectorIndexConfig;\nimport io.weaviate.docs.helper.EnvHelper;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Tag(\"crud\")\n@Tag(\"classes\")\nclass ManageDataReplicationTest {\n\n  private static WeaviateClient client;\n\n  @BeforeAll\n  public static void beforeAll() {\n    String scheme = EnvHelper.scheme(\"http\");\n    String host = EnvHelper.host(\"localhost\");\n    String port = EnvHelper.port(\"8181\");\n\n    Config config = new Config(scheme, host + \":\" + port);\n    client = new WeaviateClient(config);\n\n    Result<Boolean> result = client.schema().allDeleter().run();\n    assertThat(result).isNotNull()\n        .withFailMessage(() -> result.getError().toString())\n        .returns(false, Result::hasErrors)\n        .withFailMessage(null)\n        .returns(true, Result::getResult);\n  }\n\n  @Test\n  public void shouldManageDataClasses() {\n\n    String collectionName = \"Article\";\n\n    createArticleWithReplicationConfig(collectionName);\n    deleteCollections(collectionName);\n    createArticleWithShardingConfig(collectionName);\n    updateArticleConfiguration(collectionName);\n    readAllCollections();\n  }\n\n  private void deleteCollections(String className) {\n    client.schema().classDeleter()\n        .withClassName(className)\n        .run();\n  }\n\n  private <T> void print(Result<T> result) {\n    String json = new GsonBuilder().setPrettyPrinting().create().toJson(result.getResult());\n    System.out.println(json);\n  }\n\n  private void readAllCollections() {\n    Result<Schema> result = client.schema().getter()\n        .run();\n\n    assertThat(result).isNotNull()\n        .withFailMessage(() -> result.getError().toString())\n        .returns(false, Result::hasErrors)\n        .withFailMessage(null)\n        .extracting(Result::getResult).isNotNull()\n        .extracting(Schema::getClasses).asList()\n        .hasSize(1);\n\n    print(result);\n  }\n\n  private void createArticleWithReplicationConfig(String collectionName) {\n    // START AllReplicationSettings\n    // Configure replication settings\n    Integer replicationFactor = 3;\n    Boolean asyncEnabled = true;\n\n    // Create replication configuration\n    ReplicationConfig replicationConfig = ReplicationConfig.builder()\n        .factor(replicationFactor) // factor=3\n        .asyncEnabled(asyncEnabled) // async_enabled=True\n        .deletionStrategy(ReplicationConfig.DeletionStrategy.DELETE_ON_CONFLICT)\n        .build();\n\n    // Create the Article collection with replication configuration\n    WeaviateClass articleClass = WeaviateClass.builder()\n        .className(collectionName)\n        .description(\"Article collection with replication configuration\")\n        .replicationConfig(replicationConfig) // Set the replication config\n        .build();\n\n    // Add the collection to the schema\n    Result<Boolean> result = client.schema().classCreator()\n        .withClass(articleClass)\n        .run();\n    // END AllReplicationSettings\n\n    // Assert the result\n    assertThat(result).isNotNull()\n        .withFailMessage(() -> result.getError().toString())\n        .returns(false, Result::hasErrors)\n        .withFailMessage(null)\n        .returns(true, Result::getResult);\n\n    // Verify the replication configuration was set correctly\n    Result<WeaviateClass> classResult = client.schema().classGetter()\n        .withClassName(collectionName)\n        .run();\n\n    assertThat(classResult).isNotNull()\n        .returns(false, Result::hasErrors);\n\n    WeaviateClass createdClass = classResult.getResult();\n    assertThat(createdClass).isNotNull()\n        .extracting(WeaviateClass::getReplicationConfig).isNotNull()\n        .returns(replicationFactor, ReplicationConfig::getFactor)\n        .returns(asyncEnabled, ReplicationConfig::getAsyncEnabled)\n        .returns(ReplicationConfig.DeletionStrategy.DELETE_ON_CONFLICT,\n            ReplicationConfig::getDeletionStrategy);\n  }\n\n  private void createArticleWithShardingConfig(String collectionName) {\n    // START ShardingSettings\n    // Configure sharding settings\n    Integer virtualPerPhysical = 128;\n    Integer desiredCount = 1;\n    Integer desiredVirtualCount = 128;\n\n    // Create sharding configuration\n    ShardingConfig shardingConfig = ShardingConfig.builder()\n        .virtualPerPhysical(virtualPerPhysical) // virtual_per_physical=128\n        .desiredCount(desiredCount) // desired_count=1\n        .desiredVirtualCount(desiredVirtualCount) // desired_virtual_count=128\n        .build();\n\n    // Create the Article collection with sharding configuration\n    WeaviateClass articleClass = WeaviateClass.builder()\n        .className(collectionName)\n        .description(\"Article collection with sharding configuration\")\n        .shardingConfig(shardingConfig) // Set the sharding config\n        .build();\n\n    // Add the collection to the schema\n    Result<Boolean> result = client.schema().classCreator()\n        .withClass(articleClass)\n        .run();\n    // END ShardingSettings\n\n    // Assert the result\n    assertThat(result).isNotNull()\n        .withFailMessage(() -> result.getError().toString())\n        .returns(false, Result::hasErrors)\n        .withFailMessage(null)\n        .returns(true, Result::getResult);\n\n    // Verify the sharding configuration was set correctly\n    Result<WeaviateClass> classResult = client.schema().classGetter()\n        .withClassName(collectionName)\n        .run();\n\n    assertThat(classResult).isNotNull()\n        .returns(false, Result::hasErrors);\n\n    WeaviateClass createdClass = classResult.getResult();\n    assertThat(createdClass).isNotNull()\n        .extracting(WeaviateClass::getShardingConfig).isNotNull()\n        .returns(virtualPerPhysical, ShardingConfig::getVirtualPerPhysical)\n        .returns(desiredCount, ShardingConfig::getDesiredCount)\n        .returns(desiredVirtualCount, ShardingConfig::getDesiredVirtualCount);\n  }\n\n  private void updateArticleConfiguration(String collectionName) {\n    // START UpdateCollection\n    // Get existing collection\n    Result<WeaviateClass> existingResult = client.schema().classGetter()\n        .withClassName(collectionName)\n        .run();\n    \n    assertThat(existingResult).isNotNull()\n        .returns(false, Result::hasErrors);\n    \n    WeaviateClass existingClass = existingResult.getResult();\n\n    // Create updated configurations\n    InvertedIndexConfig invertedConfig = InvertedIndexConfig.builder()\n        .bm25(BM25Config.builder().k1(1.5f).build())\n        .build();\n\n    VectorIndexConfig vectorConfig = VectorIndexConfig.builder()\n        .filterStrategy(VectorIndexConfig.FilterStrategy.ACORN)\n        .build();\n\n    ReplicationConfig replicationConfig = ReplicationConfig.builder()\n        .deletionStrategy(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION)\n        .build();\n\n    // Update collection with new configurations - preserve critical existing configs\n    WeaviateClass updatedClass = WeaviateClass.builder()\n        .className(collectionName)\n        .shardingConfig(existingClass.getShardingConfig())     // Preserve sharding (immutable)\n        .invertedIndexConfig(invertedConfig)                   // Update\n        .vectorIndexConfig(vectorConfig)                       // Update\n        .replicationConfig(replicationConfig)                  // Update\n        .build();\n\n    Result<Boolean> updateResult = client.schema().classUpdater()\n        .withClass(updatedClass)\n        .run();\n    // END UpdateCollection\n\n    // Debug: Print error if update fails\n    if (updateResult.hasErrors()) {\n        System.out.println(\"Update failed with error: \" + updateResult.getError());\n    }\n\n    assertThat(updateResult).isNotNull()\n        .withFailMessage(() -> \"Update failed: \" + updateResult.getError())\n        .returns(false, Result::hasErrors)\n        .returns(true, Result::getResult);\n\n    // Verify updates\n    Result<WeaviateClass> verifyResult = client.schema().classGetter()\n        .withClassName(collectionName)\n        .run();\n    \n    assertThat(verifyResult).isNotNull()\n        .returns(false, Result::hasErrors);\n    \n    WeaviateClass verifyClass = verifyResult.getResult();\n\n    assertThat(verifyClass.getInvertedIndexConfig().getBm25().getK1()).isEqualTo(1.5f);\n    assertThat(verifyClass.getVectorIndexConfig().getFilterStrategy()).isEqualTo(VectorIndexConfig.FilterStrategy.ACORN);\n    assertThat(verifyClass.getReplicationConfig().getDeletionStrategy()).isEqualTo(ReplicationConfig.DeletionStrategy.NO_AUTOMATED_RESOLUTION);\n  }\n\n  private void performClusterResharding() {\n    // START ClusterResharding\n    // Doc writer / engineer TODO: New code example to go here\n    // Configure resharding parameters\n    // Map<String, Object> reshardingConfig = new HashMap<>();\n    // reshardingConfig.put(\"targetShardCount\", 6);\n    // reshardingConfig.put(\"migrationSpeed\", \"medium\"); // \"slow\", \"medium\", \"fast\"\n    // reshardingConfig.put(\"validationSettings\", Map.of(\n    //     \"enableConsistencyChecks\", true,\n    //     \"batchSize\", 1000\n    // ));\n\n    // Trigger cluster resharding\n    // Result<Boolean> reshardingResult = client.cluster().reshard()\n    //     .withConfig(reshardingConfig)\n    //     .run();\n    \n    // Monitor resharding progress\n    // Result<Map<String, Object>> statusResult = client.cluster().reshardingStatus().run();\n    // if (!statusResult.hasErrors()) {\n    //     Map<String, Object> status = statusResult.getResult();\n    //     System.out.println(\"Resharding progress: \" + status.get(\"progress\") + \"%\");\n    //     System.out.println(\"Status: \" + status.get(\"status\"));\n    // }\n\n    // Handle potential rollback\n    // if (\"failed\".equals(statusResult.getResult().get(\"status\"))) {\n    //     Result<Boolean> rollbackResult = client.cluster().rollbackResharding().run();\n    //     System.out.println(\"Rollback successful: \" + rollbackResult.getResult());\n    // }\n    // END ClusterResharding\n  }\n}\n "
    },
    {
        "path": "docs/_includes/code/howto/go/docs/manage-data.classes_test.go",
        "revised_doc": "// How-to: Manage-Data -> Classes\npackage docs\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/weaviate/weaviate-go-client/v5/weaviate\"\n\t\"github.com/weaviate/weaviate/entities/models\"\n\t\"github.com/weaviate/weaviate/entities/schema\"\n\tsharding \"github.com/weaviate/weaviate/usecases/sharding/config\"\n\t\"weaviate.io/docs/docs/helper\"\n)\n\nfunc Test_ManageDataClasses(t *testing.T) {\n\tctx := context.Background()\n\tscheme := helper.EnvScheme(\"http\")\n\thost := helper.EnvHost(\"localhost\")\n\tport := helper.EnvPort(\"8080\")\n\n\tconfig := weaviate.Config{Scheme: scheme, Host: host + \":\" + port}\n\tclient, err := weaviate.NewClient(config)\n\trequire.NoError(t, err)\n\n\terr = client.Schema().AllDeleter().Do(ctx)\n\trequire.NoError(t, err)\n\n\t// START BasicCreateCollection  // START ReadOneCollection\n\tclassName := \"Article\"\n\n\t// END BasicCreateCollection  // END ReadOneCollection\n\n\tt.Run(\"create class\", func(t *testing.T) {\n\t\t// START BasicCreateCollection\n\t\temptyClass := &models.Class{\n\t\t\tClass: className,\n\t\t}\n\n\t\t// Create the collection (also called class)\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(emptyClass).\n\t\t\tDo(ctx)\n\n\t\t// END BasicCreateCollection\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"read one class\", func(t *testing.T) {\n\t\t// START ReadOneCollection\n\t\tclass, err := client.Schema().ClassGetter().\n\t\t\tWithClassName(className).\n\t\t\tDo(ctx)\n\n\t\t// END ReadOneCollection\n\n\t\trequire.NoError(t, err)\n\n\t\t// START ReadOneCollection\n\t\tb, err := json.MarshalIndent(class, \"\", \"  \")\n\t\t// END ReadOneCollection\n\t\trequire.NoError(t, err)\n\t\t// START ReadOneCollection\n\t\tfmt.Println(string(b))\n\t\t// END ReadOneCollection\n\t})\n\n\tt.Run(\"read all classes\", func(t *testing.T) {\n\t\t// START ReadAllCollections\n\t\tschema, err := client.Schema().Getter().\n\t\t\tDo(ctx)\n\n\t\t\t// END ReadAllCollections\n\n\t\trequire.NoError(t, err)\n\n\t\t// START ReadAllCollections\n\t\tb, err := json.MarshalIndent(schema, \"\", \"  \")\n\t\t// END ReadAllCollections\n\t\trequire.NoError(t, err)\n\t\t// START ReadAllCollections\n\t\tfmt.Println(string(b))\n\t\t// END ReadAllCollections\n\t})\n\n\tt.Run(\"create class with properties\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START CreateCollectionWithProperties\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:     \"title\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:     \"body\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END CreateCollectionWithProperties\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with vectorizer\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START CreateCollectionWithVectorizer\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tVectorizer:  \"text2vec-openai\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:     \"title\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:     \"body\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END CreateCollectionWithVectorizer\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with named vectors\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"ArticleNV\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START CreateCollectionWithNamedVectors\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"ArticleNV\",\n\t\t\tDescription: \"Collection of articles with named vectors\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:     \"title\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:     \"country\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVectorConfig: map[string]models.VectorConfig{\n\t\t\t\t\"title\": {\n\t\t\t\t\tVectorizer: map[string]interface{}{\n\t\t\t\t\t\t\"text2vec-openai\": map[string]interface{}{\n\t\t\t\t\t\t\t\"sourceProperties\": []string{\"title\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tVectorIndexType: \"hnsw\",\n\t\t\t\t},\n\t\t\t\t\"title_country\": {\n\t\t\t\t\tVectorizer: map[string]interface{}{\n\t\t\t\t\t\t\"text2vec-openai\": map[string]interface{}{\n\t\t\t\t\t\t\t\"sourceProperties\": []string{\"title\", \"country\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tVectorIndexType: \"hnsw\",\n\t\t\t\t},\n\t\t\t\t\"custom_vector\": {\n\t\t\t\t\tVectorizer: map[string]interface{}{\n\t\t\t\t\t\t\"none\": map[string]interface{}{},\n\t\t\t\t\t},\n\t\t\t\t\tVectorIndexType: \"hnsw\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END CreateCollectionWithNamedVectors\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with vectorizer settings\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START ModuleSettings\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tVectorizer:  \"text2vec-cohere\",\n\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\"text2vec-cohere\": map[string]interface{}{\n\t\t\t\t\t\"model\":              \"embed-multilingual-v2.0\",\n\t\t\t\t\t\"vectorizeClassName\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END ModuleSettings\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with vector index type\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START SetVectorIndexType\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:     \"title\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:     \"country\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVectorizer:      \"text2vec-openai\",\n\t\t\tVectorIndexType: \"hnsw\", // Or \"flat\", \"dynamic\"\n\t\t}\n\t\t// END SetVectorIndexType\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with vector index parameters\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START SetVectorIndexParams\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:     \"title\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:     \"country\",\n\t\t\t\t\tDataType: schema.DataTypeText.PropString(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVectorizer:      \"text2vec-openai\",\n\t\t\tVectorIndexType: \"hnsw\",\n\t\t\tVectorIndexConfig: map[string]interface{}{\n\t\t\t\t\"bq\": map[string]interface{}{\n\t\t\t\t\t\"enabled\": true,\n\t\t\t\t},\n\t\t\t\t\"efConstruction\": 300,\n\t\t\t\t\"distance\":       \"cosine\",\n\t\t\t\t\"filterStrategy\": \"acorn\",\n\t\t\t},\n\t\t}\n\t\t// END SetVectorIndexParams\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with property settings like tokenization\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START PropModuleSettings\n\t\tvTrue := true\n\t\tvFalse := false\n\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:            \"title\",\n\t\t\t\t\tDataType:        schema.DataTypeText.PropString(),\n\t\t\t\t\tTokenization:    \"lowercase\",\n\t\t\t\t\tIndexFilterable: &vTrue,\n\t\t\t\t\tIndexSearchable: &vFalse,\n\t\t\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\t\t\"text2vec-cohere\": map[string]interface{}{\n\t\t\t\t\t\t\t\"vectorizePropertyName\": true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:            \"body\",\n\t\t\t\t\tDataType:        schema.DataTypeText.PropString(),\n\t\t\t\t\tTokenization:    \"whitespace\",\n\t\t\t\t\tIndexFilterable: &vTrue,\n\t\t\t\t\tIndexSearchable: &vTrue,\n\t\t\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\t\t\"text2vec-cohere\": map[string]interface{}{\n\t\t\t\t\t\t\t\"vectorizePropertyName\": false,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tVectorizer: \"text2vec-cohere\",\n\t\t}\n\t\t// END PropModuleSettings\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with distance metric\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START DistanceMetric\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tVectorIndexConfig: map[string]interface{}{\n\t\t\t\t\"distance\": \"cosine\",\n\t\t\t},\n\t\t}\n\t\t// END DistanceMetric\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with inverted index parameters\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START SetInvertedIndexParams\n\t\tvTrue := true\n\t\tvFalse := false\n\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tProperties: []*models.Property{\n\t\t\t\t{\n\t\t\t\t\tName:            \"title\",\n\t\t\t\t\tDataType:        schema.DataTypeText.PropString(),\n\t\t\t\t\tTokenization:    \"lowercase\",\n\t\t\t\t\tIndexFilterable: &vTrue,\n\t\t\t\t\tIndexSearchable: &vFalse,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:            \"chunk\",\n\t\t\t\t\tDataType:        schema.DataTypeText.PropString(),\n\t\t\t\t\tTokenization:    \"word\",\n\t\t\t\t\tIndexFilterable: &vTrue,\n\t\t\t\t\tIndexSearchable: &vTrue,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:              \"chunk_no\",\n\t\t\t\t\tDataType:          schema.DataTypeInt.PropString(),\n\t\t\t\t\tIndexRangeFilters: &vTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t\tInvertedIndexConfig: &models.InvertedIndexConfig{\n\t\t\t\tBm25: &models.BM25Config{\n\t\t\t\t\tB:  0.7,\n\t\t\t\t\tK1: 1.25,\n\t\t\t\t},\n\t\t\t\tIndexNullState:      true,\n\t\t\t\tIndexPropertyLength: true,\n\t\t\t\tIndexTimestamps:     true,\n\t\t\t},\n\t\t}\n\t\t// END SetInvertedIndexParams\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with reranker model integration\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START SetReranker\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tVectorizer:  \"text2vec-openai\",\n\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\"reranker-cohere\": map[string]interface{}{\n\t\t\t\t\t\"model\": \"rerank-v3.5\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END SetReranker\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"update class with reranker model integration\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t}\n\n\t\tcreation_err := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, creation_err)\n\n\t\t// START UpdateReranker\n\t\tupdatedArticleClassConfig := &models.Class{\n\t\t\t// Note: The new collection config must be provided in full,\n\t\t\t// including the configuration that is not being updated.\n\t\t\t// We suggest using the original class config as a starting point.\n\t\t\tClass: \"Article\",\n\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\"reranker-cohere\": map[string]interface{}{\n\t\t\t\t\t\"model\": \"rerank-v3.5\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END UpdateReranker\n\n\t\terr := client.Schema().ClassUpdater().\n\t\t\tWithClass(updatedArticleClassConfig).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with generative model integration\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START SetGenerative\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tVectorizer:  \"text2vec-openai\",\n\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\"generative-openai\": map[string]interface{}{\n\t\t\t\t\t\"model\": \"gpt-4o\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t// END SetGenerative\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"update collection with generative model integration\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t}\n\n\t\tcreation_err := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, creation_err)\n\n\t\t// START UpdateGenerative\n\t\tupdatedArticleClassConfig := &models.Class{\n\t\t\tClass: \"Article\",\n\t\t\tModuleConfig: map[string]interface{}{\n\t\t\t\t\"generative-cohere\": map[string]interface{}{},\n\t\t\t},\n\t\t}\n\t\t// END UpdateGenerative\n\n\t\terr := client.Schema().ClassUpdater().\n\t\t\tWithClass(updatedArticleClassConfig).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with replication settings\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START AllReplicationSettings\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tReplicationConfig: &models.ReplicationConfig{\n\t\t\t\tAsyncEnabled:     true,\n\t\t\t\tFactor:           3,\n\t\t\t\tDeletionStrategy: models.ReplicationConfigDeletionStrategyTimeBasedResolution,\n\t\t\t},\n\t\t}\n\t\t// END AllReplicationSettings\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create class with sharding settings\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START ShardingSettings\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tShardingConfig: sharding.Config{\n\t\t\t\tVirtualPerPhysical:  128,\n\t\t\t\tDesiredCount:        1,\n\t\t\t\tDesiredVirtualCount: 128,\n\t\t\t\tKey:                 sharding.DefaultKey,\n\t\t\t\tStrategy:            sharding.DefaultStrategy,\n\t\t\t\tFunction:            sharding.DefaultFunction,\n\t\t\t},\n\t\t}\n\t\t// END ShardingSettings\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"create multi-tenant class\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\t// START Multi-tenancy\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t\tMultiTenancyConfig: &models.MultiTenancyConfig{\n\t\t\t\tEnabled: true,\n\t\t\t},\n\t\t}\n\t\t// END Multi-tenancy\n\n\t\terr := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"update collection with generative model integration\", func(t *testing.T) {\n\t\terr = client.Schema().ClassDeleter().WithClassName(\"Article\").Do(ctx)\n\t\trequire.NoError(t, err)\n\n\t\tarticleClass := &models.Class{\n\t\t\tClass:       \"Article\",\n\t\t\tDescription: \"Collection of articles\",\n\t\t}\n\n\t\tcreation_err := client.Schema().ClassCreator().\n\t\t\tWithClass(articleClass).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, creation_err)\n\n\t\t// START UpdateCollection\n\t\tupdatedArticleClassConfig := &models.Class{\n\t\t\t// Note: The new collection config must be provided in full,\n\t\t\t// including the configuration that is not being updated.\n\t\t\t// We suggest using the original class config as a starting point.\n\t\t\tClass: \"Article\",\n\t\t\tInvertedIndexConfig: &models.InvertedIndexConfig{\n\t\t\t\tBm25: &models.BM25Config{\n\t\t\t\t\tK1: 1.5,\n\t\t\t\t},\n\t\t\t},\n\t\t\tVectorIndexConfig: map[string]interface{}{\n\t\t\t\t\"filterStrategy\": \"acorn\",\n\t\t\t},\n\t\t\tReplicationConfig: &models.ReplicationConfig{\n\t\t\t\tDeletionStrategy: models.ReplicationConfigDeletionStrategyTimeBasedResolution,\n\t\t\t},\n\t\t}\n\t\t// END UpdateCollection\n\n\t\terr := client.Schema().ClassUpdater().\n\t\t\tWithClass(updatedArticleClassConfig).\n\t\t\tDo(ctx)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"cluster resharding\", func(t *testing.T) {\n\t\t// START ClusterResharding\n\t\t// Doc writer / engineer TODO: New code example to go here\n\t\t// Configure resharding parameters\n\t\t// reshardingConfig := map[string]interface{}{\n\t\t//     \"targetShardCount\": 6,\n\t\t//     \"migrationSpeed\":   \"medium\", // \"slow\", \"medium\", \"fast\"\n\t\t//     \"validationSettings\": map[string]interface{}{\n\t\t//         \"enableConsistencyChecks\": true,\n\t\t//         \"batchSize\":              1000,\n\t\t//     },\n\t\t// }\n\n\t\t// Trigger cluster resharding\n\t\t// reshardingResult, err := client.Cluster().Reshard().WithConfig(reshardingConfig).Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding initiated: %v\\n\", reshardingResult)\n\n\t\t// Monitor resharding progress\n\t\t// status, err := client.Cluster().ReshardingStatus().Do(ctx)\n\t\t// if err != nil {\n\t\t//     // handle error\n\t\t//     panic(err)\n\t\t// }\n\t\t// fmt.Printf(\"Resharding progress: %v%%\\n\", status[\"progress\"])\n\t\t// fmt.Printf(\"Status: %v\\n\", status[\"status\"])\n\n\t\t// Handle potential rollback\n\t\t// if status[\"status\"] == \"failed\" {\n\t\t//     rollbackResult, err := client.Cluster().RollbackResharding().Do(ctx)\n\t\t//     if err != nil {\n\t\t//         panic(err)\n\t\t//     }\n\t\t//     fmt.Printf(\"Rollback successful: %v\\n\", rollbackResult)\n\t\t// }\n\t\t// END ClusterResharding\n\t})\n}\n"
    },
    {
        "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
        "revised_doc": "---\ntitle: Cluster Architecture\nsidebar_position: 3\ndescription: \"Node behavior and cluster coordination mechanisms in Weaviate's distributed replication system.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture']\n---\n\n\nThis page describes how the nodes or clusters in Weaviate's replication design behave.\n\nIn Weaviate, metadata replication and data replication are separate. For the metadata, Weaviate uses the [Raft](https://raft.github.io/) consensus algorithm. For data replication, Weaviate uses a leaderless design with eventual consistency.\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate is optimized to run on Kubernetes, especially when operating as a cluster. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable [fully qualified domain name (FQDN)](https://en.wikipedia.org/wiki/Fully_qualified_domain_name) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which use Raft as the consensus mechanism. It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Metadata replication: Raft\n\n:::info Added in `v1.25`\n:::\n\nWeaviate uses the [Raft consensus algorithm](https://raft.github.io/) for metadata replication, implemented with Hashicorp's [raft library](https://pkg.go.dev/github.com/hashicorp/raft). Metadata in this context includes collection definition and shard/tenant states.\n\nRaft ensures that metadata changes are consistent across the cluster. A metadata change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\n\nThis architecture ensures that metadata changes are consistent across the cluster, even in the event of (a minority of) node failures.\n\nAs a result, a Weaviate cluster will include a leader node that is responsible for metadata changes. The leader node is elected by the Raft algorithm and is responsible for coordinating metadata changes.\n\n## Data replication: Leaderless\n\nWeaviate uses a leaderless architecture for data replication. This means there is no central leader or primary node that will replicate to follower nodes. Instead, all nodes can accept writes and reads from the client, which can offer better availability. There is no single point of failure. A leaderless replication approach, also known as [Dynamo-style](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) data replication (after Amazon's implementation), has been adopted by other open-source projects like [Apache Cassandra](https://cassandra.apache.org).\n\nIn Weaviate, a coordination pattern is used to relay a client's read and write requests to the correct nodes. Unlike in a leader-based database, a coordinator node does not enforce any ordering of the operations.\n\nThe following illustration shows a leaderless replication design in Weaviate. There is one coordination node, which leads traffic from the client to the correct replicas. There is nothing special about this node; it was chosen to be the coordinator because this node received the request from the load balancer. A future request for the same data may be coordinated by a different node.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-main-quorum.png\" alt=\"Replication Architecture\" width=\"75%\"/></p>\n\nThe main advantage of a leaderless replication design is improved fault tolerance. Without a leader that handles all requests, a leaderless design offers better availability. In a single-leader design, all writes need to be processed by this leader. If this node cannot be reached or goes down, no writes can be processed. With a leaderless design, all nodes can receive write operations, so there is no risk of one master node failing.\n\nOn the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n## Dynamic Resharding\n\nWeaviate's cluster architecture supports dynamic resharding, which allows administrators to redistribute data across nodes in a multi-node cluster without downtime. This capability enhances the leaderless replication design by providing operational flexibility to optimize performance and scalability as cluster requirements evolve.\n\n### Resharding Architecture\n\nThe resharding mechanism integrates seamlessly with Weaviate's existing cluster architecture:\n\n1. **Shard Mapping Creation**: The system creates new shard mappings to define how data will be redistributed across the cluster nodes\n2. **Batch Migration**: Vector embeddings and metadata are migrated in configurable batches to prevent overwhelming individual nodes\n3. **Distributed Hash Ring Update**: The cluster's distributed hash ring is updated to reflect the new shard topology\n4. **Coordination Integration**: The resharding process works within the existing coordinator node pattern, ensuring the leaderless architecture remains intact\n\n### Operational Benefits\n\nDynamic resharding provides several architectural advantages:\n\n- **Automatic Load Balancing**: During migration, the system automatically balances the load to prevent any single node from becoming overwhelmed\n- **Configurable Migration Speed**: Batch sizes and migration speed can be throttled to control the impact on cluster performance\n- **Real-time Consistency Checks**: The system performs continuous data integrity validation during the resharding process\n- **Rollback Support**: Built-in rollback capabilities provide operational safety in case of migration failures\n- **Monitoring Integration**: Dedicated monitoring endpoints track resharding progress and system health\n\n### Impact on Read/Write Operations\n\nResharding is designed to minimize disruption to the cluster's normal operations:\n\n- **Read Operations**: Continue normally during the resharding process, maintaining query availability\n- **Write Operations**: Are temporarily queued during shard migration and replayed after the migration completes for the affected shards\n- **Coordinator Pattern**: The existing coordinator node pattern remains unchanged, ensuring seamless client interaction\n\n### Use Cases\n\nDynamic resharding supports several operational scenarios:\n\n- **Scaling Under Load**: Redistribute shards when clusters experience heavy load to improve performance\n- **Node Management**: Rebalance data after adding or removing nodes from the cluster\n- **Performance Optimization**: Adjust shard distribution based on query performance patterns and access frequencies\n\n:::info Implementation Details\nFor specific implementation guidance on triggering resharding operations, see the [cluster management documentation](/deploy/configuration/cluster-management.md). Client library support for resharding operations is available across all Weaviate SDKs.\n:::\n\n## Replication Factor\n\nimport RaftRFChangeWarning from '/_includes/1-25-replication-factor.mdx';\n\n<RaftRFChangeWarning/>\n\nIn Weaviate, data replication is enabled and controlled per collection. This means you can have different replication factors for different collections.\n\nThe replication factor (RF or n) determines how many copies of data are stored in the distributed setup. A replication factor of 1 means that there is only 1 copy of each data entry in the database setup, in other words there is no replication. A replication factor of 2 means that there are two copies of each data entry, which are present on two different nodes (replicas). Naturally, the replication factor cannot be higher than the number of nodes. Any node in the cluster can act as a coordinating node to lead queries to the correct target node(s).\n\nA replication factor of 3 is commonly used, since this provides a right balance between performance and fault tolerance. An odd number of nodes is generally preferred, as it makes it easier to resolve conflicts. In a 3-node setup, a quorum can be reached with 2 nodes. Therefore the fault tolerance is 1 node. In a 2-node setup, on the other hand, no node failures can be tolerated while still reaching consensus across nodes. In a 4-node setup, respectively, 3 nodes would be required to reach a consensus. Thus, a 3-node setup has a better fault-tolerance to cost ratio than either a 2-node or 4-node setup.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-factor.png\" alt=\"Replication Factor\" width=\"75%\"/></p>\n\n## Write operations\n\nOn a write operation, the client's request will be sent to any node in the cluster. The first node which receives the request is assigned as the coordinator. The coordinator node sends the request to a number of predefined replicas and returns the result to the client. So, any node in the cluster can be a coordinator node. A client will only have direct contact with this coordinator node. Before sending the result back to the client, the coordinator node waits for a number of write acknowledgments from different nodes depending on the configuration. How many acknowledgments Weaviate waits for, depends on the [consistency configuration](./consistency.md).\n\n**Steps**\n1. The client sends data to any node, which will be assigned as the coordinator node\n2. The coordinator node sends the data to more than one replica node in the cluster\n3. The coordinator node waits for acknowledgment from a specified proportion (let's call it `x`) of cluster nodes. Starting with v1.18, `x` is [configurable](./consistency.md), and defaults to `ALL` nodes.\n4. When `x` ACKs are received by the coordinator node, the write is successful.\n\nAs an example, consider a cluster size of 3 with replication factor of 3. So, all nodes in the distributed setup contain a copy of the data. When the client sends new data, this will be replicated to all three nodes.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size3.png\" alt=\"Replication Factor 3 with cluster size 3\" width=\"75%\"/></p>\n\nWith a cluster size of 8 and a replication factor of 3, a write operation will not be sent to all 8 nodes, but only to those three containing the replicas. The coordinating node will determine which nodes the data will be written to. Which nodes store which collections (and therefore shards) is determined by the setup of Weaviate, which is known by each node and thus each coordinator node. Where something is replicated is deterministic, so all nodes know on which shard which data will land.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size8.png\" alt=\"Replication Factor 3 with cluster size 8\" width=\"75%\"/></p>\n\n## Read operations\n\nRead operations are also coordinated by a coordinator node, which directs a query to the correct nodes that contain the data. Since one or more nodes may contain old (stale) data, the read client will determine which of the received data is the most recent before sending it to the user.\n\n**Steps**\n1. The client sends a query to Weaviate, any node in the cluster that receives the request first will act as the coordinator node\n2. The coordinator node sends the query to more than one replica node in the cluster\n3. The coordinator waits for a response from x nodes. *x is [configurable](./consistency.md) (`ALL`, `QUORUM` or `ONE`, available from v1.18, Get-Object-By-ID type requests have tunable consistency from v1.17).*\n4. The coordinator node resolves conflicting data using some metadata (e.g. timestamp, id, version number)\n5. The coordinator returns the latest data to the client\n\nIf the cluster size is 3 and the replication factor is also 3, then all nodes can serve the query. The consistency level determines how many nodes will be queried.\n\nIf the cluster size is 10 and the replication factor is 3, the 3 nodes which contain that data (collection) can serve queries, coordinated by the coordinator node. The client waits until x (the consistency level) nodes have responded.\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n"
    }
]