[
    {
        "path": "docs/docs/weaviate/concepts/cluster.md",
        "original_doc": "---\ntitle: Horizontal Scaling\nsidebar_position: 30\ndescription: \"Multi-node cluster architecture and horizontal scaling strategies for high-availability Weaviate deployments.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture', 'horizontal scaling', 'cluster', 'replication', 'sharding']\n---\n\nWeaviate can be scaled horizontally by being run on a set of multiple nodes in a cluster. This section lays out various ways in which Weaviate can be scaled, as well as factors to consider while scaling, and Weaviate's architecture in relation to horizontal scaling.\n\n## Basic concepts\n\n### Shards\n\nA collection in Weaviate comprises of one or more \"shards\", which are the basic units of data storage and retrieval. A shard will contain its own vector index, inverted indexes, and object store. Each shard can be hosted on a different node, allowing for distributed data storage and processing.\n\n![Shards explained](./img/shards_explained.png)\n\nThe number of unique shards in a single-tenant collection can only be set at collection creation time. In most cases, letting Weaviate manage the number of shards is sufficient. But in some cases, you may want to manually configure the number of shards for performance or data distribution reasons.\n\nIn a multi-tenant collection, each tenant consists of one shard. This means that the number of unique shards in a multi-tenant collection is equal to the number of tenants.\n\n![Shards in collections](./img/shards_in_collections.png)\n\n### Replicas\n\nDepending on the setup, each shard can have one or more \"replicas\", to be hosted on different nodes. This is referred to as a \"high availability\" setup, where the same data is available on multiple nodes. This allows for better read throughput and fault tolerance.\n\nYou can set the desired number of replicas, also called a replication factor, in Weaviate. This can be set a global cluster-level default using the [`REPLICATION_MINIMUM_FACTOR` environment variable](/docs/deploy/configuration/env-vars/index.md). It can also be set [per collection](/docs/weaviate/manage-collections/multi-node-setup.mdx#replication-settings), which will override the global default.\n\n## Motivation to scale Weaviate\nGenerally there are (at least) three distinct motivations to scale out horizontally which all will lead to different setups.\n\n### Motivation 1: Maximum Dataset Size\nDue to the [memory footprint of an HNSW graph](./resources.md#the-role-of-memory) it may be desirable to spread a dataset across multiple servers (\"nodes\"). In such a setup, a single collection may be split into shards and shards are spread across nodes.\n\nWeaviate does the required orchestration at import and query time fully automatically.\n\nSee [Sharding vs Replication](#sharding-vs-replication) below for trade-offs involved when running multiple shards.\n\n**Solution: Sharding across multiple nodes in a cluster**\n\n:::note\nThe ability to shard across a cluster was added in Weaviate `v1.8.0`.\n:::\n\n### Motivation 2: Higher Query Throughput\nWhen you receive more queries than a single Weaviate node can handle, it is desirable to add more Weaviate nodes which can help in responding to your users' queries.\n\nInstead of sharding across multiple nodes, you can replicate (the same data) across multiple nodes. This process also happens fully automatically and you only need to specify the desired replication factor. Sharding and replication can also be combined.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n### Motivation 3: High Availability\n\nWhen serving critical loads with Weaviate, it may be desirable to be able to keep serving queries even if a node fails completely. Such a failure could be either due to a software or OS-level crash or even a hardware issue. Other than unexpected crashes, a highly available setup can also tolerate zero-downtime updates and other maintenance tasks.\n\nTo run a highly available setup, classes must be replicated among multiple nodes.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n## Sharding vs Replication\n\nThe motivation sections above outline when it is desirable to shard your classes across multiple nodes and when it is desirable to replicate your classes - or both. This section highlights the implications of a sharded and/or replicated setup.\n\n:::note\nAll of the scenarios below assume that - as sharding or replication is increased - the cluster size is adapted accordingly. If the number of shards or the replication factor is lower than the number of nodes in the cluster, the advantages no longer apply.*\n:::\n\n### Advantages when increasing sharding\n* Run larger datasets\n* Speed up imports.\n\nTo use multiple CPUs efficiently, create multiple shards for your collection. For the fastest imports, create multiple shards even on a single node.\n\n### Disadvantages when increasing sharding\n* Query throughput does not improve when adding more sharded nodes\n\n### Advantages when increasing replication\n* System becomes highly available\n* Increased replication leads to near-linearly increased query throughput\n\n### Disadvantages when increasing replication\n* Import speed does not improve when adding more replicated nodes\n\n### Sharding Keys (\"Partitioning Keys\")\nWeaviate uses specific characteristics of an object to decide which shard it belongs to. As of `v1.8.0`, a sharding key is always the object's UUID. The sharding algorithm is a 64bit Murmur-3 hash. Other properties and other algorithms for sharding may be added in the future.\n\nNote that in a multi-tenant collection, each tenant consists of one shard.\n\n## Shard replica movement\n\n:::info Added in `v1.32`\n:::\n\nA shard replica can be moved or copied from one node to another. This is useful when you want to balance the load across nodes or when you want to change the replication factor of a part of a collection.\n\n[See this page](/docs/deploy/configuration/replica-movement.mdx) for more details on how to move shard replicas.\n\n### Use cases for moving shard replicas\n\n1. **Load Balancing**: If certain nodes are experiencing higher loads than others, moving shard replicas can help distribute the load more evenly across the cluster.\n\n2. **Scaling**: If you need to scale your cluster (e.g., adding more nodes to handle increased load), shard replicas can be moved to the new nodes to ensure that the data is evenly distributed across the cluster.\n\n3. **Node Maintenance or Replacement**: If a node requires maintenance (e.g., hardware upgrades) or replacement, shard replicas can be moved to temporary or replacement nodes to ensure continuous availability during the maintenance window.\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate - especially when running as a cluster - is optimized to run on Kubernetes. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery. All you have to do is specify the desired node count.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable fully qualified domain name (FQDN) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which [use Raft as the consensus mechanism](./replication-architecture/cluster-architecture.md#metadata-replication-raft). It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Node affinity of shards and/or replication shards\n\nWeaviate tries to select the node with the most available disk space.\n\nThis only applies when creating a new class, rather than when adding more data to an existing single class.\n\n<details>\n  <summary>Pre-<code>v1.18.1</code> behavior</summary>\n\nIn versions `v1.8.0`-`v1.18.0`, users could not specify the node-affinity of a specific shard or replication shard.\n\nShards were assigned to 'live' nodes in a round-robin fashion starting with a random node.\n\n</details>\n\n## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* As of `v1.8.0`, dynamically scaling a cluster is not fully supported yet. New nodes can be added to an existing cluster, however it does not affect the ownership of shards. Existing nodes can not yet be removed if data is present, as shards are not yet being moved to other nodes prior to a removal of a node.\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n",
        "revised_doc": "---\ntitle: Horizontal Scaling\nsidebar_position: 30\ndescription: \"Multi-node cluster architecture and horizontal scaling strategies for high-availability Weaviate deployments.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture', 'horizontal scaling', 'cluster', 'replication', 'sharding']\n---\n\nWeaviate can be scaled horizontally by being run on a set of multiple nodes in a cluster. This section lays out various ways in which Weaviate can be scaled, as well as factors to consider while scaling, and Weaviate's architecture in relation to horizontal scaling.\n\n## Basic concepts\n\n### Shards\n\nA collection in Weaviate comprises of one or more \"shards\", which are the basic units of data storage and retrieval. A shard will contain its own vector index, inverted indexes, and object store. Each shard can be hosted on a different node, allowing for distributed data storage and processing.\n\n![Shards explained](./img/shards_explained.png)\n\nThe number of unique shards in a single-tenant collection can only be set at collection creation time. In most cases, letting Weaviate manage the number of shards is sufficient. But in some cases, you may want to manually configure the number of shards for performance or data distribution reasons.\n\nIn a multi-tenant collection, each tenant consists of one shard. This means that the number of unique shards in a multi-tenant collection is equal to the number of tenants.\n\n![Shards in collections](./img/shards_in_collections.png)\n\n### Replicas\n\nDepending on the setup, each shard can have one or more \"replicas\", to be hosted on different nodes. This is referred to as a \"high availability\" setup, where the same data is available on multiple nodes. This allows for better read throughput and fault tolerance.\n\nYou can set the desired number of replicas, also called a replication factor, in Weaviate. This can be set a global cluster-level default using the [`REPLICATION_MINIMUM_FACTOR` environment variable](/docs/deploy/configuration/env-vars/index.md). It can also be set [per collection](/docs/weaviate/manage-collections/multi-node-setup.mdx#replication-settings), which will override the global default.\n\n## Motivation to scale Weaviate\nGenerally there are (at least) three distinct motivations to scale out horizontally which all will lead to different setups.\n\n### Motivation 1: Maximum Dataset Size\nDue to the [memory footprint of an HNSW graph](./resources.md#the-role-of-memory) it may be desirable to spread a dataset across multiple servers (\"nodes\"). In such a setup, a single collection may be split into shards and shards are spread across nodes.\n\nWeaviate does the required orchestration at import and query time fully automatically.\n\nSee [Sharding vs Replication](#sharding-vs-replication) below for trade-offs involved when running multiple shards.\n\n**Solution: Sharding across multiple nodes in a cluster**\n\n:::note\nThe ability to shard across a cluster was added in Weaviate `v1.8.0`.\n:::\n\n### Motivation 2: Higher Query Throughput\nWhen you receive more queries than a single Weaviate node can handle, it is desirable to add more Weaviate nodes which can help in responding to your users' queries.\n\nInstead of sharding across multiple nodes, you can replicate (the same data) across multiple nodes. This process also happens fully automatically and you only need to specify the desired replication factor. Sharding and replication can also be combined.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n### Motivation 3: High Availability\n\nWhen serving critical loads with Weaviate, it may be desirable to be able to keep serving queries even if a node fails completely. Such a failure could be either due to a software or OS-level crash or even a hardware issue. Other than unexpected crashes, a highly available setup can also tolerate zero-downtime updates and other maintenance tasks.\n\nTo run a highly available setup, classes must be replicated among multiple nodes.\n\n**Solution: Replicate your classes across multiple nodes in a cluster**\n\n## Sharding vs Replication\n\nThe motivation sections above outline when it is desirable to shard your classes across multiple nodes and when it is desirable to replicate your classes - or both. This section highlights the implications of a sharded and/or replicated setup.\n\n:::note\nAll of the scenarios below assume that - as sharding or replication is increased - the cluster size is adapted accordingly. If the number of shards or the replication factor is lower than the number of nodes in the cluster, the advantages no longer apply.*\n:::\n\n### Advantages when increasing sharding\n* Run larger datasets\n* Speed up imports.\n\nTo use multiple CPUs efficiently, create multiple shards for your collection. For the fastest imports, create multiple shards even on a single node.\n\n### Disadvantages when increasing sharding\n* Query throughput does not improve when adding more sharded nodes\n\n### Advantages when increasing replication\n* System becomes highly available\n* Increased replication leads to near-linearly increased query throughput\n\n### Disadvantages when increasing replication\n* Import speed does not improve when adding more replicated nodes\n\n### Sharding Keys (\"Partitioning Keys\")\nWeaviate uses specific characteristics of an object to decide which shard it belongs to. As of `v1.8.0`, a sharding key is always the object's UUID. The sharding algorithm is a 64bit Murmur-3 hash. Other properties and other algorithms for sharding may be added in the future.\n\nNote that in a multi-tenant collection, each tenant consists of one shard.\n\n## Shard replica movement\n\n:::info Added in `v1.32`\n:::\n\nA shard replica can be moved or copied from one node to another. This is useful when you want to balance the load across nodes or when you want to change the replication factor of a part of a collection.\n\n[See this page](/docs/deploy/configuration/replica-movement.mdx) for more details on how to move shard replicas.\n\n### Use cases for moving shard replicas\n\n1. **Load Balancing**: If certain nodes are experiencing higher loads than others, moving shard replicas can help distribute the load more evenly across the cluster.\n\n2. **Scaling**: If you need to scale your cluster (e.g., adding more nodes to handle increased load), shard replicas can be moved to the new nodes to ensure that the data is evenly distributed across the cluster.\n\n3. **Node Maintenance or Replacement**: If a node requires maintenance (e.g., hardware upgrades) or replacement, shard replicas can be moved to temporary or replacement nodes to ensure continuous availability during the maintenance window.\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate - especially when running as a cluster - is optimized to run on Kubernetes. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery. All you have to do is specify the desired node count.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable fully qualified domain name (FQDN) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which [use Raft as the consensus mechanism](./replication-architecture/cluster-architecture.md#metadata-replication-raft). It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Node affinity of shards and/or replication shards\n\nWeaviate tries to select the node with the most available disk space.\n\nThis only applies when creating a new class, rather than when adding more data to an existing single class.\n\n<details>\n  <summary>Pre-<code>v1.18.1</code> behavior</summary>\n\nIn versions `v1.8.0`-`v1.18.0`, users could not specify the node-affinity of a specific shard or replication shard.\n\nShards were assigned to 'live' nodes in a round-robin fashion starting with a random node.\n\n</details>\n\n## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* With the introduction of cluster resharding, Weaviate now supports dynamic scaling of clusters, allowing administrators to redistribute data across nodes efficiently and without downtime.\n\n## Cluster Resharding\n\nWeaviate now supports dynamic cluster resharding, a powerful feature that allows administrators to redistribute data across nodes for improved performance and scalability. This capability enables you to adjust the number of shards in an existing cluster without experiencing downtime.\n\n### Key Resharding Capabilities\n\n- **Automatic Load Balancing**: Prevents node overload during data migration\n- **Configurable Migration**: Control batch sizes and migration speed\n- **Data Integrity**: Real-time consistency checks ensure data accuracy\n- **Resilience**: Rollback support in case of migration failures\n- **Monitoring**: Dedicated endpoints to track resharding progress\n\n### Resharding Process\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint. During the resharding operation:\n- Read operations continue normally\n- Write operations are temporarily queued and replayed after shard migration completes\n\n### Typical Use Cases\n\n1. **Scaling Under Heavy Load**: Redistribute data when cluster performance becomes constrained\n2. **Node Rebalancing**: Optimize data distribution after adding or removing nodes\n3. **Query Performance Optimization**: Adjust shard distribution to match evolving query patterns\n\nFor specific API usage and configuration details, refer to the [multi-node setup documentation](/docs/weaviate/manage-collections/multi-node-setup.mdx).\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n"
    },
    {
        "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
        "original_doc": "---\ntitle: Multi-node setup\nsidebar_position: 5\nimage: og/docs/howto.jpg\n---\n\nimport SkipLink from \"/src/components/SkipValidationLink\";\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport FilteredTextBlock from \"@site/src/components/Documentation/FilteredTextBlock\";\nimport PyCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.py\";\nimport PyCodeV3 from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v3.py\";\nimport TSCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.ts\";\nimport TSCodeLegacy from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v2.ts\";\nimport JavaReplicationCode from '!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java';\nimport GoCode from \"!!raw-loader!/_includes/code/howto/go/docs/manage-data.classes_test.go\";\n\n## Replication settings\n\nimport RaftRFChangeWarning from \"/_includes/1-25-replication-factor.mdx\";\n\n<RaftRFChangeWarning />\n\nConfigure replication settings, such as [async replication](/deploy/configuration/replication.md#async-replication-settings) and [deletion resolution strategy](../concepts/replication-architecture/consistency.md#deletion-resolution-strategies).\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START AllReplicationSettings\"\n      endMarker=\"# END AllReplicationSettings\"\n      language=\"py\"\n      docRefs={[\n        \"weaviate.collections.classes.html#weaviate.collections.classes.config.Configure\"\n      ]}\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START AllReplicationSettings\"\n    endMarker=\"# END AllReplicationSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"class\": \"Article\",\n    \"properties\": [\n        {\n            \"dataType\": [\n                \"string\"\n            ],\n            \"description\": \"Title of the article\",\n            \"name\": \"title\"\n        }\n    ],\n    \"replicationConfig\": {\n      \"factor\": 3,\n      \"asyncEnabled\": true,\n      \"deletionStrategy\": \"TimeBasedResolution\"\n    }\n}' \\\nhttp://localhost:8080/v1/schema\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nTo use replication factors greater than one, use a [multi-node deployment](/deploy/installation-guides/docker-installation.md#multi-node-configuration).\n\nFor details on the configuration parameters, see the following:\n\n- [Replication](/weaviate/config-refs/collections.mdx#replication)\n\n</details>\n\n## Sharding settings\n\nConfigure sharding per collection.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ShardingSettings\"\n      endMarker=\"# END ShardingSettings\"\n      language=\"py\"\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START ShardingSettings\"\n    endMarker=\"# END ShardingSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"js2\" label=\"JS/TS Client v2\">\n  <FilteredTextBlock\n    text={TSCodeLegacy}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"tsv2\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nFor details on the configuration parameters, see the following:\n\n- [Sharding](/weaviate/config-refs/collections.mdx#sharding)\n\n</details>\n\n## Inspect shards (for a collection)\n\nAn index itself can be comprised of multiple shards.\n\nimport CodeSchemaShardsGet from \"/_includes/code/howto/manage-data.shards.inspect.mdx\";\n\n<CodeSchemaShardsGet />\n\n## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)\n\n## Questions and feedback\n\nimport DocsFeedback from \"/_includes/docs-feedback.mdx\";\n\n<DocsFeedback />\n",
        "revised_doc": "---\ntitle: Multi-node setup\nsidebar_position: 5\nimage: og/docs/howto.jpg\n---\n\nimport SkipLink from \"/src/components/SkipValidationLink\";\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport FilteredTextBlock from \"@site/src/components/Documentation/FilteredTextBlock\";\nimport PyCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.py\";\nimport PyCodeV3 from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v3.py\";\nimport TSCode from \"!!raw-loader!/_includes/code/howto/manage-data.collections.ts\";\nimport TSCodeLegacy from \"!!raw-loader!/_includes/code/howto/manage-data.collections-v2.ts\";\nimport JavaReplicationCode from '!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java';\nimport GoCode from \"!!raw-loader!/_includes/code/howto/go/docs/manage-data.classes_test.go\";\n\n## Replication settings\n\nimport RaftRFChangeWarning from \"/_includes/1-25-replication-factor.mdx\";\n\n<RaftRFChangeWarning />\n\nConfigure replication settings, such as [async replication](/deploy/configuration/replication.md#async-replication-settings) and [deletion resolution strategy](../concepts/replication-architecture/consistency.md#deletion-resolution-strategies).\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START AllReplicationSettings\"\n      endMarker=\"# END AllReplicationSettings\"\n      language=\"py\"\n      docRefs={[\n        \"weaviate.collections.classes.html#weaviate.collections.classes.config.Configure\"\n      ]}\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START AllReplicationSettings\"\n    endMarker=\"# END AllReplicationSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START AllReplicationSettings\"\n    endMarker=\"// END AllReplicationSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n  <TabItem value=\"curl\" label=\"cURL\">\n\n```bash\ncurl \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"class\": \"Article\",\n    \"properties\": [\n        {\n            \"dataType\": [\n                \"string\"\n            ],\n            \"description\": \"Title of the article\",\n            \"name\": \"title\"\n        }\n    ],\n    \"replicationConfig\": {\n      \"factor\": 3,\n      \"asyncEnabled\": true,\n      \"deletionStrategy\": \"TimeBasedResolution\"\n    }\n}' \\\nhttp://localhost:8080/v1/schema\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nTo use replication factors greater than one, use a [multi-node deployment](/deploy/installation-guides/docker-installation.md#multi-node-configuration).\n\nFor details on the configuration parameters, see the following:\n\n- [Replication](/weaviate/config-refs/collections.mdx#replication)\n\n</details>\n\n## Sharding settings\n\nConfigure sharding per collection.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"py\" label=\"Python Client v4\">\n    <FilteredTextBlock\n      text={PyCode}\n      startMarker=\"# START ShardingSettings\"\n      endMarker=\"# END ShardingSettings\"\n      language=\"py\"\n    />\n  </TabItem>\n\n<TabItem value=\"py3\" label=\"Python Client v3\">\n  <FilteredTextBlock\n    text={PyCodeV3}\n    startMarker=\"# START ShardingSettings\"\n    endMarker=\"# END ShardingSettings\"\n    language=\"pyv3\"\n  />\n</TabItem>\n\n<TabItem value=\"js\" label=\"JS/TS Client v3\">\n  <FilteredTextBlock\n    text={TSCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"ts\"\n  />\n</TabItem>\n\n<TabItem value=\"js2\" label=\"JS/TS Client v2\">\n  <FilteredTextBlock\n    text={TSCodeLegacy}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"tsv2\"\n  />\n</TabItem>\n\n<TabItem value=\"java\" label=\"Java\">\n  <FilteredTextBlock\n    text={JavaReplicationCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"java\"\n  />\n</TabItem>\n\n<TabItem value=\"go\" label=\"Go\">\n  <FilteredTextBlock\n    text={GoCode}\n    startMarker=\"// START ShardingSettings\"\n    endMarker=\"// END ShardingSettings\"\n    language=\"gonew\"\n  />\n</TabItem>\n\n</Tabs>\n\n<details>\n  <summary>\n     Additional information\n  </summary>\n\nFor details on the configuration parameters, see the following:\n\n- [Sharding](/weaviate/config-refs/collections.mdx#sharding)\n\n</details>\n\n## Inspect shards (for a collection)\n\nAn index itself can be comprised of multiple shards.\n\nimport CodeSchemaShardsGet from \"/_includes/code/howto/manage-data.shards.inspect.mdx\";\n\n<CodeSchemaShardsGet />\n\n## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster Resharding\n\nWeaviate now supports dynamic resharding of multi-node clusters to redistribute data across nodes, improving performance and scalability.\n\n### Key Features\n- Dynamically adjust the number of shards in an existing cluster without downtime\n- Automatic load balancing during migration to prevent node overload\n- Configurable batch sizes and migration speed throttling\n- Real-time consistency checks to ensure data integrity\n- Built-in rollback support in case of migration failures\n- Monitoring endpoints to track resharding progress\n\n### Resharding Configuration\n\nThe resharding operation is triggered via the `/v1/cluster/resharding` API endpoint with the following parameters:\n\n- `target_shard_count`: Desired number of shards after redistribution\n- `migration_speed`: Controls the rate of data migration\n- `validation_settings`: Configuration for data consistency checks\n\n:::note Client Libraries\nNative resharding functions for Weaviate client libraries (Python, JS/TS, Go, Java) will be available. Exact syntax is pending finalization.\n:::\n\n### Operational Behavior\n- Read operations continue normally during resharding\n- Write operations are temporarily queued and replayed after shard migration completes\n\n### Use Cases\n- Scaling up clusters under heavy load\n- Rebalancing after node additions or removals\n- Optimizing shard distribution for specific query performance patterns\n\nFor more details on the architectural implementation, see [Cluster Architecture](/weaviate/concepts/cluster-architecture).\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)\n\n## Questions and feedback\n\nimport DocsFeedback from \"/_includes/docs-feedback.mdx\";\n\n<DocsFeedback />\n"
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.py",
        "original_doc": "# How-to: Manage-Data -> Classes\nimport os\n\n# ================================\n# ===== INSTANTIATION-COMMON =====\n# ================================\n\nimport weaviate\n\n# Instantiate the client with the OpenAI API key\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\n            \"OPENAI_API_KEY\"\n        ]  # Replace with your inference API key\n    }\n)\n\n# ================================\n# ===== CREATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START BasicCreateCollection\nclient.collections.create(\"Article\")\n# END BasicCreateCollection\n\n# Test\nassert client.collections.exists(\"Article\")\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH PROPERTIES =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START CreateCollectionWithProperties\nfrom weaviate.classes.config import Property, DataType\n\n# Note that you can use `client.collections.create_from_dict()` to create a collection from a v3-client-style JSON object\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END CreateCollectionWithProperties\n\n# Test\narticles = client.collections.use(\"Article\")\nassert client.collections.exists(\"Article\")\nassert len(articles.config.get().properties) == 2\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH VECTORIZER =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Vectorizer\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-end\n    properties=[  # properties configuration is optional\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END Vectorizer\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH NAMED VECTORS =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"ArticleNV\")\n\n# START BasicNamedVectors\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"ArticleNV\",\n    # highlight-start\n    vector_config=[\n        # Set a named vector with the \"text2vec-cohere\" vectorizer\n        Configure.Vectors.text2vec_cohere(\n            name=\"title\",\n            source_properties=[\"title\"],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set another named vector with the \"text2vec-openai\" vectorizer\n        Configure.Vectors.text2vec_openai(\n            name=\"title_country\",\n            source_properties=[\n                \"title\",\n                \"country\",\n            ],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set a named vector for your own uploaded vectors\n        Configure.Vectors.self_provided(\n            name=\"custom_vector\",\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n    ],\n    # highlight-end\n    properties=[  # Define properties\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"country\", data_type=DataType.TEXT),\n    ],\n)\n# END BasicNamedVectors\n\n# Test\ncollection = client.collections.use(\"ArticleNV\")\nconfig = collection.config.get()\n\nassertion_dicts = {\n    \"title\": [\"title\"],\n    \"title_country\": [\"title\", \"country\"],\n    \"custom_vector\": None,\n}\nfor k, v in config.vector_config.items():\n    assert (\n        v.vectorizer.source_properties == assertion_dicts[k]\n    )  # Test that the source properties are correctly set\n\n# ===========================\n# ===== SET VECTOR INDEX TYPE =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexType\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(),  # Use the HNSW index\n        # vector_index_config=Configure.VectorIndex.flat(),  # Use the FLAT index\n        # vector_index_config=Configure.VectorIndex.dynamic(),  # Use the DYNAMIC index\n        # highlight-end\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END SetVectorIndexType\n\n# Test\nfrom weaviate.collections.classes.config import _VectorIndexConfigHNSW\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n# ===========================\n# ===== SET VECTOR INDEX PARAMETERS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexParams\nfrom weaviate.classes.config import (\n    Configure,\n    Property,\n    DataType,\n    VectorDistances,\n    VectorFilterStrategy,\n)\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            ef_construction=300,\n            distance_metric=VectorDistances.COSINE,\n            filter_strategy=VectorFilterStrategy.SWEEPING,  # or ACORN (Available from Weaviate v1.27.0)\n        ),\n        # highlight-end\n    ),\n)\n# END SetVectorIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.filter_strategy == \"sweeping\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n\n# ===================================================================\n# ===== CREATE A COLLECTION WITH CUSTOM INVERTED INDEX SETTINGS =====\n# ===================================================================\n\nclient.collections.delete(\"Article\")\n\n# START SetInvertedIndexParams\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # Additional settings not shown\n    properties=[  # properties configuration is optional\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk_number\",\n            data_type=DataType.INT,\n            # highlight-start\n            index_range_filters=True,\n            # highlight-end\n        ),\n    ],\n    # highlight-start\n    inverted_index_config=Configure.inverted_index(  # Optional\n        bm25_b=0.7,\n        bm25_k1=1.25,\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True,\n    ),\n    # highlight-end\n)\n# END SetInvertedIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.inverted_index_config.bm25.b == 0.7\nassert config.inverted_index_config.bm25.k1 == 1.25\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetReranker\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.cohere(),\n    # highlight-end\n)\n# END SetReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.voyageai(),\n    # highlight-end\n)\n\n# START UpdateReranker\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    reranker_config=Reconfigure.Reranker.cohere()  # Update the reranker module\n    # highlight-end\n)\n# END UpdateReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetGenerative\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4o\"  # set your generative model (optional parameter)\n    ),\n    # highlight-end\n)\n# END SetGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-openai\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(),\n    # highlight-end\n)\n\n# START UpdateGenerative\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    generative_config=Reconfigure.Generative.cohere()  # Update the generative module\n    # highlight-end\n)\n# END UpdateGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ======================================================\n# ===== MULTI-VECTOR EMBEDDINGS (ColBERT, ColPali)\n# ======================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorCollection\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        # The factory function will automatically enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n        ),\n        # highlight-end\n        # Example 2 - User-provided multi-vector representations\n        # Must explicitly enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.self_provided(\n            # highlight-end\n            name=\"custom_multi_vector\",\n        ),\n    ],\n    properties=[Property(name=\"text\", data_type=DataType.TEXT)],\n    # Additional parameters not shown\n)\n# END MultiValueVectorCollection\n\n# ==========================================\n# ===== MULTI-VECTOR EMBEDDINGS MUVERA\n# ==========================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorMuvera\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(\n                # Optional parameters for tuning MUVERA\n                # ksim: 4,\n                # dprojections: 16,\n                # repetitions: 20,\n            ),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorMuvera\n\n# ================================================\n# ===== MULTI-VECTOR EMBEDDINGS QUANTIZATION\n# ================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorPQ\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorPQ\n\n# ===========================\n# ===== MODULE SETTINGS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ModuleSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_cohere(\n        model=\"embed-multilingual-v2.0\", vectorize_collection_name=True\n    ),\n    # highlight-end\n)\n# END ModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"default\"].vectorizer.model[\"model\"] == \"embed-multilingual-v2.0\"\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START PropModuleSettings\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            vectorize_property_name=True,  # Use \"title\" as part of the value to vectorize\n            tokenization=Tokenization.LOWERCASE,  # Use \"lowecase\" tokenization\n            description=\"The title of the article.\",  # Optional description\n            # highlight-end\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            skip_vectorization=True,  # Don't vectorize this property\n            tokenization=Tokenization.WHITESPACE,  # Use \"whitespace\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END PropModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nfor p in config.properties:\n    if p.name == \"title\":\n        assert p.tokenization.name == \"LOWERCASE\"\n    elif p.name == \"body\":\n        assert p.tokenization.name == \"WHITESPACE\"\n\n\n# ====================================\n# ======= TRIGRAM TOKENIZATION =======\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START TrigramTokenization\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            tokenization=Tokenization.TRIGRAM,  # Use \"trigram\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END TrigramTokenization\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# START AddNamedVectors\nfrom weaviate.classes.config import Configure\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_vector(\n    vector_config=Configure.Vectors.text2vec_cohere(\n        name=\"body_vector\",\n        source_properties=[\"body\"],\n    )\n)\n# END AddNamedVectors\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"body_vector\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.properties[0].tokenization.name == \"TRIGRAM\"\n\n\n# ===========================\n# ===== DISTANCE METRIC =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START DistanceMetric\nfrom weaviate.classes.config import Configure, VectorDistances\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            distance_metric=VectorDistances.COSINE\n        ),\n        # highlight-end\n    )\n)\n# END DistanceMetric\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.distance_metric.value == \"cosine\"\n\nclient.close()\n\n# =======================\n# ===== REPLICATION =====\n# =======================\n\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# clean slate\nclient.collections.delete(\"Article\")\n# START ReplicationSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n    ),\n    # highlight-end\n)\n# END ReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.factor == 3\n\nclient.close()\n\n# =======================\n# ===== REPLICATION WITH ASYNC REPAIR ====\n# =======================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AsyncRepair\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,\n    ),\n    # highlight-end\n)\n# END AsyncRepair\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n# assert config.replication_config.factor == 3   #ASYNC NEEDS TEST\n\nclient.close()\n\n# ==============================================\n# ===== ALL REPLICATION SETTINGS\n# ==============================================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AllReplicationSettings\nfrom weaviate.classes.config import Configure, ReplicationDeletionStrategy\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,  # Enable asynchronous repair\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION,  # Added in v1.28; Set the deletion conflict resolution strategy\n    ),\n    # highlight-end\n)\n# END AllReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.async_enabled == True\nassert (\n    config.replication_config.deletion_strategy\n    == ReplicationDeletionStrategy.TIME_BASED_RESOLUTION\n)\n\nclient.close()\n\n# ====================\n# ===== SHARDING =====\n# ====================\n\nclient = weaviate.connect_to_local()\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ShardingSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    sharding_config=Configure.sharding(\n        virtual_per_physical=128,\n        desired_count=1,\n        desired_virtual_count=128,\n    ),\n    # highlight-end\n)\n# END ShardingSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.sharding_config.virtual_per_physical == 128\nassert config.sharding_config.desired_count == 1\nassert config.sharding_config.desired_virtual_count == 128\n\n# =========================\n# ===== MULTI-TENANCY =====\n# =========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Multi-tenancy\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    multi_tenancy_config=Configure.multi_tenancy(True),\n    # highlight-end\n)\n# END Multi-tenancy\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.multi_tenancy_config.enabled == True\n\n# ==========================\n# ===== ADD A PROPERTY =====\n# ==========================\n\n# START AddProp\nfrom weaviate.classes.config import Property, DataType\n\n# Get the Article collection object\narticles = client.collections.use(\"Article\")\n\n# Add a new property\narticles.config.add_property(\n    # highlight-start\n    prop=Property(name=\"body\", data_type=DataType.TEXT)\n    # highlight-end\n)\n# END AddProp\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert len(config.properties) == 1\nassert config.properties[0].name == \"body\"\n\n# ================================\n# ===== CHECK IF A COLLECTION EXISTS =====\n# ================================\n\n# START CheckIfExists\nexists = client.collections.exists(\"Article\")  # Returns a boolean\n# END CheckIfExists\n\n# ================================\n# ===== READ A COLLECTION =====\n# ================================\n\n# START ReadOneCollection\narticles = client.collections.use(\"Article\")\narticles_config = articles.config.get()\n\nprint(articles_config)\n# END ReadOneCollection\n\nassert articles_config.name == \"Article\"\n\n\n# ================================\n# ===== READ ALL COLLECTIONS =====\n# ================================\n\n# START ReadAllCollections\nresponse = client.collections.list_all(simple=False)\n\nprint(response)\n# END ReadAllCollections\n\nassert type(response) == dict\nassert \"Article\" in response\n\n\n# ================================\n# ===== UPDATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# Define and create a collection\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    name=\"Article\",\n    inverted_index_config=Configure.inverted_index(bm25_b=0.7, bm25_k1=1.2),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n        ),\n    ],\n)\nold_config = articles.config.get()\n\n\n# Create an object to check that it remains mutable\nfor _ in range(5):\n    articles.data.insert({\"title\": \"A grand day out.\"})\n\n\n# START UpdateCollection\nfrom weaviate.classes.config import (\n    Reconfigure,\n    VectorFilterStrategy,\n    ReplicationDeletionStrategy,\n)\n\narticles = client.collections.use(\"Article\")\n\n# Update the collection definition\narticles.config.update(\n    description=\"An updated collection description.\",\n    property_descriptions={\n        \"title\": \"The updated title description for article\",\n    },  # Available from Weaviate v1.31.0\n    inverted_index_config=Reconfigure.inverted_index(bm25_k1=1.5),\n    vector_config=Reconfigure.Vectors.update(\n        name=\"default\",\n        vector_index_config=Reconfigure.VectorIndex.hnsw(\n            filter_strategy=VectorFilterStrategy.ACORN  # Available from Weaviate v1.27.0\n        ),\n    ),\n    replication_config=Reconfigure.replication(\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION  # Available from Weaviate v1.28.0\n    ),\n)\n# END UpdateCollection\n\nnew_config = articles.config.get()\n\nassert old_config.inverted_index_config.bm25.k1 == 1.2\nassert new_config.inverted_index_config.bm25.k1 == 1.5\n\nproperty_descriptions = {prop.name: prop.description for prop in new_config.properties}\nassert property_descriptions[\"title\"] == \"The updated title description for article\"\n\n# ================================\n# ===== DELETE A COLLECTION =====\n# ================================\n\ncollection_name = \"Article\"\n\n# START DeleteCollection\n# collection_name can be a string (\"Article\") or a list of strings ([\"Article\", \"Category\"])\nclient.collections.delete(\n    collection_name\n)  # THIS WILL DELETE THE SPECIFIED COLLECTION(S) AND THEIR OBJECTS\n\n# Note: you can also delete all collections in the Weaviate instance with:\n# client.collections.delete_all()\n# END DeleteCollection\n\n# ========================================\n# AddProperty\n# ========================================\n\nclient.collections.create(name=\"Article\")\n\n# START AddProperty\nfrom weaviate.classes.config import Property, DataType\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_property(Property(name=\"onHomepage\", data_type=DataType.BOOL))\n# END AddProperty\n\n# ========================================\n# InspectCollectionShards\n# ========================================\n\n# START InspectCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.get_shards()\n# highlight-end\nprint(article_shards)\n# END InspectCollectionShards\n\n\n# ========================================\n# UpdateCollectionShards\n# ========================================\n\nshards = articles.config.get_shards()\nshard_names = [s.name for s in shards]\n\n# START UpdateCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.update_shards(\n    status=\"READY\",\n    shard_names=shard_names,  # The names (List[str]) of the shard to update (or a shard name)\n)\n# highlight-end\n\nprint(article_shards)\n# END UpdateCollectionShards\n\n\nclient.close()\n",
        "revised_doc": "# How-to: Manage-Data -> Classes\nimport os\n\n# ================================\n# ===== INSTANTIATION-COMMON =====\n# ================================\n\nimport weaviate\n\n# Instantiate the client with the OpenAI API key\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\n            \"OPENAI_API_KEY\"\n        ]  # Replace with your inference API key\n    }\n)\n\n# ================================\n# ===== CREATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START BasicCreateCollection\nclient.collections.create(\"Article\")\n# END BasicCreateCollection\n\n# Test\nassert client.collections.exists(\"Article\")\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH PROPERTIES =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START CreateCollectionWithProperties\nfrom weaviate.classes.config import Property, DataType\n\n# Note that you can use `client.collections.create_from_dict()` to create a collection from a v3-client-style JSON object\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END CreateCollectionWithProperties\n\n# Test\narticles = client.collections.use(\"Article\")\nassert client.collections.exists(\"Article\")\nassert len(articles.config.get().properties) == 2\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH VECTORIZER =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Vectorizer\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-end\n    properties=[  # properties configuration is optional\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END Vectorizer\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH NAMED VECTORS =====\n# ===============================================\n\n# Clean slate\nclient.collections.delete(\"ArticleNV\")\n\n# START BasicNamedVectors\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"ArticleNV\",\n    # highlight-start\n    vector_config=[\n        # Set a named vector with the \"text2vec-cohere\" vectorizer\n        Configure.Vectors.text2vec_cohere(\n            name=\"title\",\n            source_properties=[\"title\"],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set another named vector with the \"text2vec-openai\" vectorizer\n        Configure.Vectors.text2vec_openai(\n            name=\"title_country\",\n            source_properties=[\n                \"title\",\n                \"country\",\n            ],  # (Optional) Set the source property(ies)\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n        # Set a named vector for your own uploaded vectors\n        Configure.Vectors.self_provided(\n            name=\"custom_vector\",\n            vector_index_config=Configure.VectorIndex.hnsw(),  # (Optional) Set vector index options\n        ),\n    ],\n    # highlight-end\n    properties=[  # Define properties\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"country\", data_type=DataType.TEXT),\n    ],\n)\n# END BasicNamedVectors\n\n# Test\ncollection = client.collections.use(\"ArticleNV\")\nconfig = collection.config.get()\n\nassertion_dicts = {\n    \"title\": [\"title\"],\n    \"title_country\": [\"title\", \"country\"],\n    \"custom_vector\": None,\n}\nfor k, v in config.vector_config.items():\n    assert (\n        v.vectorizer.source_properties == assertion_dicts[k]\n    )  # Test that the source properties are correctly set\n\n# ===========================\n# ===== SET VECTOR INDEX TYPE =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexType\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(),  # Use the HNSW index\n        # vector_index_config=Configure.VectorIndex.flat(),  # Use the FLAT index\n        # vector_index_config=Configure.VectorIndex.dynamic(),  # Use the DYNAMIC index\n        # highlight-end\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n)\n# END SetVectorIndexType\n\n# Test\nfrom weaviate.collections.classes.config import _VectorIndexConfigHNSW\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-openai\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n# ===========================\n# ===== SET VECTOR INDEX PARAMETERS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START SetVectorIndexParams\nfrom weaviate.classes.config import (\n    Configure,\n    Property,\n    DataType,\n    VectorDistances,\n    VectorFilterStrategy,\n)\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        name=\"default\",\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            ef_construction=300,\n            distance_metric=VectorDistances.COSINE,\n            filter_strategy=VectorFilterStrategy.SWEEPING,  # or ACORN (Available from Weaviate v1.27.0)\n        ),\n        # highlight-end\n    ),\n)\n# END SetVectorIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.filter_strategy == \"sweeping\"\nassert isinstance(config.vector_config[\"default\"].vector_index_config, _VectorIndexConfigHNSW)\n\n\n# ===================================================================\n# ===== CREATE A COLLECTION WITH CUSTOM INVERTED INDEX SETTINGS =====\n# ===================================================================\n\nclient.collections.delete(\"Article\")\n\n# START SetInvertedIndexParams\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    # Additional settings not shown\n    properties=[  # properties configuration is optional\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            index_filterable=True,\n            index_searchable=True,\n            # highlight-end\n        ),\n        Property(\n            name=\"chunk_number\",\n            data_type=DataType.INT,\n            # highlight-start\n            index_range_filters=True,\n            # highlight-end\n        ),\n    ],\n    # highlight-start\n    inverted_index_config=Configure.inverted_index(  # Optional\n        bm25_b=0.7,\n        bm25_k1=1.25,\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True,\n    ),\n    # highlight-end\n)\n# END SetInvertedIndexParams\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.inverted_index_config.bm25.b == 0.7\nassert config.inverted_index_config.bm25.k1 == 1.25\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetReranker\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.cohere(),\n    # highlight-end\n)\n# END SetReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S RERANKER MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    reranker_config=Configure.Reranker.voyageai(),\n    # highlight-end\n)\n\n# START UpdateReranker\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    reranker_config=Reconfigure.Reranker.cohere()  # Update the reranker module\n    # highlight-end\n)\n# END UpdateReranker\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.reranker_config.reranker == \"reranker-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ===============================================\n# ===== CREATE A COLLECTION WITH A GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\n# START SetGenerative\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4o\"  # set your generative model (optional parameter)\n    ),\n    # highlight-end\n)\n# END SetGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-openai\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n# ===============================================\n# ===== UPDATE A COLLECTION'S GENERATIVE MODULE =====\n# ===============================================\n\nclient.collections.delete(\"Article\")\n\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # highlight-start\n    generative_config=Configure.Generative.openai(),\n    # highlight-end\n)\n\n# START UpdateGenerative\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.use(\"Article\")\n\ncollection.config.update(\n    # highlight-start\n    generative_config=Reconfigure.Generative.cohere()  # Update the generative module\n    # highlight-end\n)\n# END UpdateGenerative\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.generative_config.generative == \"generative-cohere\"\n\n# Delete the collection to recreate it\nclient.collections.delete(\"Article\")\n\n\n# ======================================================\n# ===== MULTI-VECTOR EMBEDDINGS (ColBERT, ColPali)\n# ======================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorCollection\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        # The factory function will automatically enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n        ),\n        # highlight-end\n        # Example 2 - User-provided multi-vector representations\n        # Must explicitly enable multi-vector support for the HNSW index\n        # highlight-start\n        Configure.MultiVectors.self_provided(\n            # highlight-end\n            name=\"custom_multi_vector\",\n        ),\n    ],\n    properties=[Property(name=\"text\", data_type=DataType.TEXT)],\n    # Additional parameters not shown\n)\n# END MultiValueVectorCollection\n\n# ==========================================\n# ===== MULTI-VECTOR EMBEDDINGS MUVERA\n# ==========================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorMuvera\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(\n                # Optional parameters for tuning MUVERA\n                # ksim: 4,\n                # dprojections: 16,\n                # repetitions: 20,\n            ),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            encoding=Configure.VectorIndex.MultiVector.Encoding.muvera(),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorMuvera\n\n# ================================================\n# ===== MULTI-VECTOR EMBEDDINGS QUANTIZATION\n# ================================================\n\n# Clean slate\nclient.collections.delete(\"DemoCollection\")\n\n# START MultiValueVectorPQ\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"DemoCollection\",\n    vector_config=[\n        # Example 1 - Use a model integration\n        Configure.MultiVectors.text2vec_jinaai(\n            name=\"jina_colbert\",\n            source_properties=[\"text\"],\n            # highlight-start\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n            # highlight-end\n        ),\n        # Example 2 - User-provided multi-vector representations\n        Configure.MultiVectors.self_provided(\n            name=\"custom_multi_vector\",\n            quantizer=Configure.VectorIndex.Quantizer.pq(training_limit=50000),\n        ),\n    ],\n    # Additional parameters not shown\n)\n# END MultiValueVectorPQ\n\n# ===========================\n# ===== MODULE SETTINGS =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ModuleSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    vector_config=Configure.Vectors.text2vec_cohere(\n        model=\"embed-multilingual-v2.0\", vectorize_collection_name=True\n    ),\n    # highlight-end\n)\n# END ModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"default\"].vectorizer.model[\"model\"] == \"embed-multilingual-v2.0\"\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START PropModuleSettings\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            vectorize_property_name=True,  # Use \"title\" as part of the value to vectorize\n            tokenization=Tokenization.LOWERCASE,  # Use \"lowecase\" tokenization\n            description=\"The title of the article.\",  # Optional description\n            # highlight-end\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            skip_vectorization=True,  # Don't vectorize this property\n            tokenization=Tokenization.WHITESPACE,  # Use \"whitespace\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END PropModuleSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nfor p in config.properties:\n    if p.name == \"title\":\n        assert p.tokenization.name == \"LOWERCASE\"\n    elif p.name == \"body\":\n        assert p.tokenization.name == \"WHITESPACE\"\n\n\n# ====================================\n# ======= TRIGRAM TOKENIZATION =======\n# ====================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START TrigramTokenization\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_cohere(),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            # highlight-start\n            tokenization=Tokenization.TRIGRAM,  # Use \"trigram\" tokenization\n            # highlight-end\n        ),\n    ],\n)\n# END TrigramTokenization\n\n# ====================================\n# ===== MODULE SETTINGS PROPERTY =====\n# ====================================\n\n# START AddNamedVectors\nfrom weaviate.classes.config import Configure\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_vector(\n    vector_config=Configure.Vectors.text2vec_cohere(\n        name=\"body_vector\",\n        source_properties=[\"body\"],\n    )\n)\n# END AddNamedVectors\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n\nassert config.vector_config[\"default\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.vector_config[\"body_vector\"].vectorizer.vectorizer == \"text2vec-cohere\"\nassert config.properties[0].tokenization.name == \"TRIGRAM\"\n\n\n# ===========================\n# ===== DISTANCE METRIC =====\n# ===========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START DistanceMetric\nfrom weaviate.classes.config import Configure, VectorDistances\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        # highlight-start\n        vector_index_config=Configure.VectorIndex.hnsw(\n            distance_metric=VectorDistances.COSINE\n        ),\n        # highlight-end\n    )\n)\n# END DistanceMetric\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.vector_config[\"default\"].vector_index_config.distance_metric.value == \"cosine\"\n\n# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()\n\n# =======================\n# ===== REPLICATION =====\n# =======================\n\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# clean slate\nclient.collections.delete(\"Article\")\n# START ReplicationSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n    ),\n    # highlight-end\n)\n# END ReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.factor == 3\n\n# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()\n\n# =======================\n# ===== REPLICATION WITH ASYNC REPAIR ====\n# =======================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AsyncRepair\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,\n    ),\n    # highlight-end\n)\n# END AsyncRepair\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\n# assert config.replication_config.factor == 3   #ASYNC NEEDS TEST\n\n# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()\n\n# ==============================================\n# ===== ALL REPLICATION SETTINGS\n# ==============================================\n\n# Connect to a setting with 3 replicas\nclient = weaviate.connect_to_local(port=8180)  # Port for demo setup with 3 replicas\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START AllReplicationSettings\nfrom weaviate.classes.config import Configure, ReplicationDeletionStrategy\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    replication_config=Configure.replication(\n        factor=3,\n        async_enabled=True,  # Enable asynchronous repair\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION,  # Added in v1.28; Set the deletion conflict resolution strategy\n    ),\n    # highlight-end\n)\n# END AllReplicationSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.replication_config.async_enabled == True\nassert (\n    config.replication_config.deletion_strategy\n    == ReplicationDeletionStrategy.TIME_BASED_RESOLUTION\n)\n\n# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()\n\n# ====================\n# ===== SHARDING =====\n# ====================\n\nclient = weaviate.connect_to_local()\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START ShardingSettings\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    sharding_config=Configure.sharding(\n        virtual_per_physical=128,\n        desired_count=1,\n        desired_virtual_count=128,\n    ),\n    # highlight-end\n)\n# END ShardingSettings\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.sharding_config.virtual_per_physical == 128\nassert config.sharding_config.desired_count == 1\nassert config.sharding_config.desired_virtual_count == 128\n\n# =========================\n# ===== MULTI-TENANCY =====\n# =========================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# START Multi-tenancy\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    \"Article\",\n    # highlight-start\n    multi_tenancy_config=Configure.multi_tenancy(True),\n    # highlight-end\n)\n# END Multi-tenancy\n\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert config.multi_tenancy_config.enabled == True\n\n# ==========================\n# ===== ADD A PROPERTY =====\n# ==========================\n\n# START AddProp\nfrom weaviate.classes.config import Property, DataType\n\n# Get the Article collection object\narticles = client.collections.use(\"Article\")\n\n# Add a new property\narticles.config.add_property(\n    # highlight-start\n    prop=Property(name=\"body\", data_type=DataType.TEXT)\n    # highlight-end\n)\n# END AddProp\n\n# Test\ncollection = client.collections.use(\"Article\")\nconfig = collection.config.get()\nassert len(config.properties) == 1\nassert config.properties[0].name == \"body\"\n\n# ================================\n# ===== CHECK IF A COLLECTION EXISTS =====\n# ================================\n\n# START CheckIfExists\nexists = client.collections.exists(\"Article\")  # Returns a boolean\n# END CheckIfExists\n\n# ================================\n# ===== READ A COLLECTION =====\n# ================================\n\n# START ReadOneCollection\narticles = client.collections.use(\"Article\")\narticles_config = articles.config.get()\n\nprint(articles_config)\n# END ReadOneCollection\n\nassert articles_config.name == \"Article\"\n\n\n# ================================\n# ===== READ ALL COLLECTIONS =====\n# ================================\n\n# START ReadAllCollections\nresponse = client.collections.list_all(simple=False)\n\nprint(response)\n# END ReadAllCollections\n\nassert type(response) == dict\nassert \"Article\" in response\n\n\n# ================================\n# ===== UPDATE A COLLECTION =====\n# ================================\n\n# Clean slate\nclient.collections.delete(\"Article\")\n\n# Define and create a collection\nfrom weaviate.classes.config import Configure\n\nclient.collections.create(\n    name=\"Article\",\n    inverted_index_config=Configure.inverted_index(bm25_b=0.7, bm25_k1=1.2),\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n        ),\n    ],\n)\nold_config = articles.config.get()\n\n\n# Create an object to check that it remains mutable\nfor _ in range(5):\n    articles.data.insert({\"title\": \"A grand day out.\"})\n\n\n# START UpdateCollection\nfrom weaviate.classes.config import (\n    Reconfigure,\n    VectorFilterStrategy,\n    ReplicationDeletionStrategy,\n)\n\narticles = client.collections.use(\"Article\")\n\n# Update the collection definition\narticles.config.update(\n    description=\"An updated collection description.\",\n    property_descriptions={\n        \"title\": \"The updated title description for article\",\n    },  # Available from Weaviate v1.31.0\n    inverted_index_config=Reconfigure.inverted_index(bm25_k1=1.5),\n    vector_config=Reconfigure.Vectors.update(\n        name=\"default\",\n        vector_index_config=Reconfigure.VectorIndex.hnsw(\n            filter_strategy=VectorFilterStrategy.ACORN  # Available from Weaviate v1.27.0\n        ),\n    ),\n    replication_config=Reconfigure.replication(\n        deletion_strategy=ReplicationDeletionStrategy.TIME_BASED_RESOLUTION  # Available from Weaviate v1.28.0\n    ),\n)\n# END UpdateCollection\n\nnew_config = articles.config.get()\n\nassert old_config.inverted_index_config.bm25.k1 == 1.2\nassert new_config.inverted_index_config.bm25.k1 == 1.5\n\nproperty_descriptions = {prop.name: prop.description for prop in new_config.properties}\nassert property_descriptions[\"title\"] == \"The updated title description for article\"\n\n# ================================\n# ===== DELETE A COLLECTION =====\n# ================================\n\ncollection_name = \"Article\"\n\n# START DeleteCollection\n# collection_name can be a string (\"Article\") or a list of strings ([\"Article\", \"Category\"])\nclient.collections.delete(\n    collection_name\n)  # THIS WILL DELETE THE SPECIFIED COLLECTION(S) AND THEIR OBJECTS\n\n# Note: you can also delete all collections in the Weaviate instance with:\n# client.collections.delete_all()\n# END DeleteCollection\n\n# ========================================\n# AddProperty\n# ========================================\n\nclient.collections.create(name=\"Article\")\n\n# START AddProperty\nfrom weaviate.classes.config import Property, DataType\n\narticles = client.collections.use(\"Article\")\n\narticles.config.add_property(Property(name=\"onHomepage\", data_type=DataType.BOOL))\n# END AddProperty\n\n# ========================================\n# InspectCollectionShards\n# ========================================\n\n# START InspectCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.get_shards()\n# highlight-end\nprint(article_shards)\n# END InspectCollectionShards\n\n\n# ========================================\n# UpdateCollectionShards\n# ========================================\n\nshards = articles.config.get_shards()\nshard_names = [s.name for s in shards]\n\n# START UpdateCollectionShards\narticles = client.collections.use(\"Article\")\n\n# highlight-start\narticle_shards = articles.config.update_shards(\n    status=\"READY\",\n    shard_names=shard_names,  # The names (List[str]) of the shard to update (or a shard name)\n)\n# highlight-end\n\nprint(article_shards)\n# END UpdateCollectionShards\n\n\n# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()\n"
    },
    {
        "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
        "original_doc": "---\ntitle: Cluster Architecture\nsidebar_position: 3\ndescription: \"Node behavior and cluster coordination mechanisms in Weaviate's distributed replication system.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture']\n---\n\n\nThis page describes how the nodes or clusters in Weaviate's replication design behave.\n\nIn Weaviate, metadata replication and data replication are separate. For the metadata, Weaviate uses the [Raft](https://raft.github.io/) consensus algorithm. For data replication, Weaviate uses a leaderless design with eventual consistency.\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate is optimized to run on Kubernetes, especially when operating as a cluster. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable [fully qualified domain name (FQDN)](https://en.wikipedia.org/wiki/Fully_qualified_domain_name) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which use Raft as the consensus mechanism. It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Metadata replication: Raft\n\n:::info Added in `v1.25`\n:::\n\nWeaviate uses the [Raft consensus algorithm](https://raft.github.io/) for metadata replication, implemented with Hashicorp's [raft library](https://pkg.go.dev/github.com/hashicorp/raft). Metadata in this context includes collection definition and shard/tenant states.\n\nRaft ensures that metadata changes are consistent across the cluster. A metadata change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\n\nThis architecture ensures that metadata changes are consistent across the cluster, even in the event of (a minority of) node failures.\n\nAs a result, a Weaviate cluster will include a leader node that is responsible for metadata changes. The leader node is elected by the Raft algorithm and is responsible for coordinating metadata changes.\n\n## Data replication: Leaderless\n\nWeaviate uses a leaderless architecture for data replication. This means there is no central leader or primary node that will replicate to follower nodes. Instead, all nodes can accept writes and reads from the client, which can offer better availability. There is no single point of failure. A leaderless replication approach, also known as [Dynamo-style](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) data replication (after Amazon's implementation), has been adopted by other open-source projects like [Apache Cassandra](https://cassandra.apache.org).\n\nIn Weaviate, a coordination pattern is used to relay a client's read and write requests to the correct nodes. Unlike in a leader-based database, a coordinator node does not enforce any ordering of the operations.\n\nThe following illustration shows a leaderless replication design in Weaviate. There is one coordination node, which leads traffic from the client to the correct replicas. There is nothing special about this node; it was chosen to be the coordinator because this node received the request from the load balancer. A future request for the same data may be coordinated by a different node.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-main-quorum.png\" alt=\"Replication Architecture\" width=\"75%\"/></p>\n\nThe main advantage of a leaderless replication design is improved fault tolerance. Without a leader that handles all requests, a leaderless design offers better availability. In a single-leader design, all writes need to be processed by this leader. If this node cannot be reached or goes down, no writes can be processed. With a leaderless design, all nodes can receive write operations, so there is no risk of one master node failing.\n\nOn the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n\n## Replication Factor\n\nimport RaftRFChangeWarning from '/_includes/1-25-replication-factor.mdx';\n\n<RaftRFChangeWarning/>\n\nIn Weaviate, data replication is enabled and controlled per collection. This means you can have different replication factors for different collections.\n\nThe replication factor (RF or n) determines how many copies of data are stored in the distributed setup. A replication factor of 1 means that there is only 1 copy of each data entry in the database setup, in other words there is no replication. A replication factor of 2 means that there are two copies of each data entry, which are present on two different nodes (replicas). Naturally, the replication factor cannot be higher than the number of nodes. Any node in the cluster can act as a coordinating node to lead queries to the correct target node(s).\n\nA replication factor of 3 is commonly used, since this provides a right balance between performance and fault tolerance. An odd number of nodes is generally preferred, as it makes it easier to resolve conflicts. In a 3-node setup, a quorum can be reached with 2 nodes. Therefore the fault tolerance is 1 node. In a 2-node setup, on the other hand, no node failures can be tolerated while still reaching consensus across nodes. In a 4-node setup, respectively, 3 nodes would be required to reach a consensus. Thus, a 3-node setup has a better fault-tolerance to cost ratio than either a 2-node or 4-node setup.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-factor.png\" alt=\"Replication Factor\" width=\"75%\"/></p>\n\n## Write operations\n\nOn a write operation, the client's request will be sent to any node in the cluster. The first node which receives the request is assigned as the coordinator. The coordinator node sends the request to a number of predefined replicas and returns the result to the client. So, any node in the cluster can be a coordinator node. A client will only have direct contact with this coordinator node. Before sending the result back to the client, the coordinator node waits for a number of write acknowledgments from different nodes depending on the configuration. How many acknowledgments Weaviate waits for, depends on the [consistency configuration](./consistency.md).\n\n**Steps**\n1. The client sends data to any node, which will be assigned as the coordinator node\n2. The coordinator node sends the data to more than one replica node in the cluster\n3. The coordinator node waits for acknowledgment from a specified proportion (let's call it `x`) of cluster nodes. Starting with v1.18, `x` is [configurable](./consistency.md), and defaults to `ALL` nodes.\n4. When `x` ACKs are received by the coordinator node, the write is successful.\n\nAs an example, consider a cluster size of 3 with replication factor of 3. So, all nodes in the distributed setup contain a copy of the data. When the client sends new data, this will be replicated to all three nodes.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size3.png\" alt=\"Replication Factor 3 with cluster size 3\" width=\"75%\"/></p>\n\nWith a cluster size of 8 and a replication factor of 3, a write operation will not be sent to all 8 nodes, but only to those three containing the replicas. The coordinating node will determine which nodes the data will be written to. Which nodes store which collections (and therefore shards) is determined by the setup of Weaviate, which is known by each node and thus each coordinator node. Where something is replicated is deterministic, so all nodes know on which shard which data will land.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size8.png\" alt=\"Replication Factor 3 with cluster size 8\" width=\"75%\"/></p>\n\n## Read operations\n\nRead operations are also coordinated by a coordinator node, which directs a query to the correct nodes that contain the data. Since one or more nodes may contain old (stale) data, the read client will determine which of the received data is the most recent before sending it to the user.\n\n**Steps**\n1. The client sends a query to Weaviate, any node in the cluster that receives the request first will act as the coordinator node\n2. The coordinator node sends the query to more than one replica node in the cluster\n3. The coordinator waits for a response from x nodes. *x is [configurable](./consistency.md) (`ALL`, `QUORUM` or `ONE`, available from v1.18, Get-Object-By-ID type requests have tunable consistency from v1.17).*\n4. The coordinator node resolves conflicting data using some metadata (e.g. timestamp, id, version number)\n5. The coordinator returns the latest data to the client\n\nIf the cluster size is 3 and the replication factor is also 3, then all nodes can serve the query. The consistency level determines how many nodes will be queried.\n\nIf the cluster size is 10 and the replication factor is 3, the 3 nodes which contain that data (collection) can serve queries, coordinated by the coordinator node. The client waits until x (the consistency level) nodes have responded.\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n",
        "revised_doc": "---\ntitle: Cluster Architecture\nsidebar_position: 3\ndescription: \"Node behavior and cluster coordination mechanisms in Weaviate's distributed replication system.\"\nimage: og/docs/concepts.jpg\n# tags: ['architecture']\n---\n\n\nThis page describes how the nodes or clusters in Weaviate's replication design behave.\n\nIn Weaviate, metadata replication and data replication are separate. For the metadata, Weaviate uses the [Raft](https://raft.github.io/) consensus algorithm. For data replication, Weaviate uses a leaderless design with eventual consistency.\n\n## Node Discovery\n\nBy default, Weaviate nodes in a cluster use a gossip-like protocol through [Hashicorp's Memberlist](https://github.com/hashicorp/memberlist) to communicate node state and failure scenarios.\n\nWeaviate is optimized to run on Kubernetes, especially when operating as a cluster. The [Weaviate Helm chart](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) makes use of a `StatefulSet` and a headless `Service` that automatically configures node discovery.\n\n<details>\n  <summary>FQDN for node discovery</summary>\n\n:::caution Added in `v1.25.15` and removed in `v1.30`\n\nThis was an experimental feature. Use with caution.\n\n:::\n\nThere can be a situation where IP-address based node discovery is not optimal. In such cases, you can set `RAFT_ENABLE_FQDN_RESOLVER` and `RAFT_FQDN_RESOLVER_TLD` [environment variables](/deploy/configuration/env-vars/index.md#multi-node-instances) to enable [fully qualified domain name (FQDN)](https://en.wikipedia.org/wiki/Fully_qualified_domain_name) based node discovery.\n\nIf this feature is enabled, Weaviate uses the FQDN resolver to resolve the node name to the node IP address for metadata (e.g., Raft) communication.\n\n:::info FQDN: For metadata changes only\nThis feature is only used for metadata changes which use Raft as the consensus mechanism. It does not affect data read/write operations.\n:::\n\n#### Examples of when to use FQDN for node discovery\n\nThe use of FQDN can resolve a situation where if IP addresses are re-used across different clusters, the nodes in one cluster could mistakenly discover nodes in another cluster.\n\nIt can also be useful when using services (for example, Kubernetes) where the IP of the services is different from the actual node IP, but it proxies the connection to the node.\n\n#### Environment variables for FQDN node discovery\n\n`RAFT_ENABLE_FQDN_RESOLVER` is a Boolean flag. This flag enables the FQDN resolver. If set to `true`, Weaviate uses the FQDN resolver to resolve the node name to the node IP address. If set to `false`, Weaviate uses the memberlist lookup to resolve the node name to the node IP address. The default value is `false`.\n\n`RAFT_FQDN_RESOLVER_TLD` is a string that is appended in the format `[node-id].[tld]` when resolving a node-id to an IP address, where `[tld]` is the top-level domain.\n\nTo use this feature, set `RAFT_ENABLE_FQDN_RESOLVER` to `true`.\n\n</details>\n\n## Metadata replication: Raft\n\n:::info Added in `v1.25`\n:::\n\nWeaviate uses the [Raft consensus algorithm](https://raft.github.io/) for metadata replication, implemented with Hashicorp's [raft library](https://pkg.go.dev/github.com/hashicorp/raft). Metadata in this context includes collection definition and shard/tenant states.\n\nRaft ensures that metadata changes are consistent across the cluster. A metadata change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\n\nThis architecture ensures that metadata changes are consistent across the cluster, even in the event of (a minority of) node failures.\n\nAs a result, a Weaviate cluster will include a leader node that is responsible for metadata changes. The leader node is elected by the Raft algorithm and is responsible for coordinating metadata changes.\n\n## Data replication: Leaderless\n\nWeaviate uses a leaderless architecture for data replication. This means there is no central leader or primary node that will replicate to follower nodes. Instead, all nodes can accept writes and reads from the client, which can offer better availability. There is no single point of failure. A leaderless replication approach, also known as [Dynamo-style](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) data replication (after Amazon's implementation), has been adopted by other open-source projects like [Apache Cassandra](https://cassandra.apache.org).\n\nIn Weaviate, a coordination pattern is used to relay a client's read and write requests to the correct nodes. Unlike in a leader-based database, a coordinator node does not enforce any ordering of the operations.\n\nThe following illustration shows a leaderless replication design in Weaviate. There is one coordination node, which leads traffic from the client to the correct replicas. There is nothing special about this node; it was chosen to be the coordinator because this node received the request from the load balancer. A future request for the same data may be coordinated by a different node.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-main-quorum.png\" alt=\"Replication Architecture\" width=\"75%\"/></p>\n\nThe main advantage of a leaderless replication design is improved fault tolerance. Without a leader that handles all requests, a leaderless design offers better availability. In a single-leader design, all writes need to be processed by this leader. If this node cannot be reached or goes down, no writes can be processed. With a leaderless design, all nodes can receive write operations, so there is no risk of one master node failing.\n\nOn the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n## Dynamic Resharding\n\nIn response to evolving cluster performance needs, Weaviate now supports dynamic resharding, a sophisticated mechanism that allows administrators to redistribute data across nodes without system downtime. This feature enhances the leaderless architecture by providing granular control over data distribution and load balancing.\n\n### Resharding Mechanism\n\nDynamic resharding works by creating new shard mappings and migrating vector embeddings and metadata in carefully controlled batches. The process involves:\n\n1. **Shard Mapping Reconfiguration**: Generate a new distributed hash ring that defines how data will be redistributed across nodes.\n2. **Batch Migration**: Transfer vector embeddings and metadata in configurable batch sizes to minimize performance impact.\n3. **Distributed Coordination**: Leverage the existing leaderless coordination pattern to manage migration without disrupting the overall system architecture.\n\n### Key Capabilities\n\n- **Automatic Load Balancing**: Intelligent migration algorithms prevent node overload during resharding.\n- **Configurable Migration**: Administrators can control batch sizes and migration speed to minimize performance interruptions.\n- **Consistency Guarantees**: Real-time consistency checks ensure data integrity throughout the resharding process.\n- **Operational Safety**: \n  - Rollback support in case of migration failures\n  - Monitoring endpoints to track resharding progress\n  - Minimal disruption to existing read/write patterns\n\n### Impact on Operations\n\nDuring resharding:\n- Read operations continue normally without interruption\n- Write operations are temporarily queued and replayed after shard migration completes\n- No downtime is required for the cluster\n\n### Use Cases\n\nDynamic resharding is particularly valuable in scenarios such as:\n- Scaling clusters under heavy load\n- Rebalancing after node additions or removals\n- Optimizing shard distribution for specific query performance patterns\n\n:::note Implementation Details\nFor specific implementation instructions, refer to the [Cluster Resharding](/path/to/resharding/guide) documentation.\n:::\n\n## Replication Factor\n\nimport RaftRFChangeWarning from '/_includes/1-25-replication-factor.mdx';\n\n<RaftRFChangeWarning/>\n\nIn Weaviate, data replication is enabled and controlled per collection. This means you can have different replication factors for different collections.\n\nThe replication factor (RF or n) determines how many copies of data are stored in the distributed setup. A replication factor of 1 means that there is only 1 copy of each data entry in the database setup, in other words there is no replication. A replication factor of 2 means that there are two copies of each data entry, which are present on two different nodes (replicas). Naturally, the replication factor cannot be higher than the number of nodes. Any node in the cluster can act as a coordinating node to lead queries to the correct target node(s).\n\nA replication factor of 3 is commonly used, since this provides a right balance between performance and fault tolerance. An odd number of nodes is generally preferred, as it makes it easier to resolve conflicts. In a 3-node setup, a quorum can be reached with 2 nodes. Therefore the fault tolerance is 1 node. In a 2-node setup, on the other hand, no node failures can be tolerated while still reaching consensus across nodes. In a 4-node setup, respectively, 3 nodes would be required to reach a consensus. Thus, a 3-node setup has a better fault-tolerance to cost ratio than either a 2-node or 4-node setup.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-factor.png\" alt=\"Replication Factor\" width=\"75%\"/></p>\n\n## Write operations\n\nOn a write operation, the client's request will be sent to any node in the cluster. The first node which receives the request is assigned as the coordinator. The coordinator node sends the request to a number of predefined replicas and returns the result to the client. So, any node in the cluster can be a coordinator node. A client will only have direct contact with this coordinator node. Before sending the result back to the client, the coordinator node waits for a number of write acknowledgments from different nodes depending on the configuration. How many acknowledgments Weaviate waits for, depends on the [consistency configuration](./consistency.md).\n\n**Steps**\n1. The client sends data to any node, which will be assigned as the coordinator node\n2. The coordinator node sends the data to more than one replica node in the cluster\n3. The coordinator node waits for acknowledgment from a specified proportion (let's call it `x`) of cluster nodes. Starting with v1.18, `x` is [configurable](./consistency.md), and defaults to `ALL` nodes.\n4. When `x` ACKs are received by the coordinator node, the write is successful.\n\nAs an example, consider a cluster size of 3 with replication factor of 3. So, all nodes in the distributed setup contain a copy of the data. When the client sends new data, this will be replicated to all three nodes.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size3.png\" alt=\"Replication Factor 3 with cluster size 3\" width=\"75%\"/></p>\n\nWith a cluster size of 8 and a replication factor of 3, a write operation will not be sent to all 8 nodes, but only to those three containing the replicas. The coordinating node will determine which nodes the data will be written to. Which nodes store which collections (and therefore shards) is determined by the setup of Weaviate, which is known by each node and thus each coordinator node. Where something is replicated is deterministic, so all nodes know on which shard which data will land.\n\n<p align=\"center\"><img src=\"/img/docs/replication-architecture/replication-rf3-size8.png\" alt=\"Replication Factor 3 with cluster size 8\" width=\"75%\"/></p>\n\n## Read operations\n\nRead operations are also coordinated by a coordinator node, which directs a query to the correct nodes that contain the data. Since one or more nodes may contain old (stale) data, the read client will determine which of the received data is the most recent before sending it to the user.\n\n**Steps**\n1. The client sends a query to Weaviate, any node in the cluster that receives the request first will act as the coordinator node\n2. The coordinator node sends the query to more than one replica node in the cluster\n3. The coordinator waits for a response from x nodes. *x is [configurable](./consistency.md) (`ALL`, `QUORUM` or `ONE`, available from v1.18, Get-Object-By-ID type requests have tunable consistency from v1.17).*\n4. The coordinator node resolves conflicting data using some metadata (e.g. timestamp, id, version number)\n5. The coordinator returns the latest data to the client\n\nIf the cluster size is 3 and the replication factor is also 3, then all nodes can serve the query. The consistency level determines how many nodes will be queried.\n\nIf the cluster size is 10 and the replication factor is 3, the 3 nodes which contain that data (collection) can serve queries, coordinated by the coordinator node. The client waits until x (the consistency level) nodes have responded.\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>\n"
    }
]