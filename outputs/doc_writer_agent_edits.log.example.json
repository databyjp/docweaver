[
    {
        "path": "docs/docs/weaviate/concepts/cluster.md",
        "edits": [
            {
                "path": "docs/docs/weaviate/concepts/cluster.md",
                "edits": [
                    {
                        "replace_section": "## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* As of `v1.8.0`, dynamically scaling a cluster is not fully supported yet. New nodes can be added to an existing cluster, however it does not affect the ownership of shards. Existing nodes can not yet be removed if data is present, as shards are not yet being moved to other nodes prior to a removal of a node.",
                        "replacement_txt": "## Consistency and current limitations\n\n* Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.\n* As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.\n* With the introduction of cluster resharding, Weaviate now supports dynamic scaling of clusters, allowing administrators to redistribute data across nodes efficiently and without downtime."
                    },
                    {
                        "replace_section": "## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>",
                        "replacement_txt": "## Cluster Resharding\n\nWeaviate now supports dynamic cluster resharding, a powerful feature that allows administrators to redistribute data across nodes for improved performance and scalability. This capability enables you to adjust the number of shards in an existing cluster without experiencing downtime.\n\n### Key Resharding Capabilities\n\n- **Automatic Load Balancing**: Prevents node overload during data migration\n- **Configurable Migration**: Control batch sizes and migration speed\n- **Data Integrity**: Real-time consistency checks ensure data accuracy\n- **Resilience**: Rollback support in case of migration failures\n- **Monitoring**: Dedicated endpoints to track resharding progress\n\n### Resharding Process\n\nResharding is triggered via the `/v1/cluster/resharding` API endpoint. During the resharding operation:\n- Read operations continue normally\n- Write operations are temporarily queued and replayed after shard migration completes\n\n### Typical Use Cases\n\n1. **Scaling Under Heavy Load**: Redistribute data when cluster performance becomes constrained\n2. **Node Rebalancing**: Optimize data distribution after adding or removing nodes\n3. **Query Performance Optimization**: Adjust shard distribution to match evolving query patterns\n\nFor specific API usage and configuration details, refer to the [multi-node setup documentation](/docs/weaviate/manage-collections/multi-node-setup.mdx).\n\n## Questions and feedback\n\nimport DocsFeedback from '/_includes/docs-feedback.mdx';\n\n<DocsFeedback/>"
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    },
    {
        "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster Resharding\n\nWeaviate now supports dynamic resharding of multi-node clusters to redistribute data across nodes, improving performance and scalability.\n\n### Key Features\n- Dynamically adjust the number of shards in an existing cluster without downtime\n- Automatic load balancing during migration to prevent node overload\n- Configurable batch sizes and migration speed throttling\n- Real-time consistency checks to ensure data integrity\n- Built-in rollback support in case of migration failures\n- Monitoring endpoints to track resharding progress\n\n### Resharding Configuration\n\nThe resharding operation is triggered via the `/v1/cluster/resharding` API endpoint with the following parameters:\n\n- `target_shard_count`: Desired number of shards after redistribution\n- `migration_speed`: Controls the rate of data migration\n- `validation_settings`: Configuration for data consistency checks\n\n:::note Client Libraries\nNative resharding functions for Weaviate client libraries (Python, JS/TS, Go, Java) will be available. Exact syntax is pending finalization.\n:::\n\n### Operational Behavior\n- Read operations continue normally during resharding\n- Write operations are temporarily queued and replayed after shard migration completes\n\n### Use Cases\n- Scaling up clusters under heavy load\n- Rebalancing after node additions or removals\n- Optimizing shard distribution for specific query performance patterns\n\nFor more details on the architectural implementation, see [Cluster Architecture](/weaviate/concepts/cluster-architecture).\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/manage-data.collections.py",
                "edits": [
                    {
                        "replace_section": "client.close()",
                        "replacement_txt": "# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/manage-data.collections.ts",
                "edits": [
                    {
                        "replace_section": "client.close();",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nimport { Configure, ReshardingStatus } from 'weaviate-client';\n\nasync function performResharding() {\n  const articles = client.collections.use('Article');\n\n  // Doc writer / engineer TODO: Exact method to be confirmed\n  const reshardingOperation = await articles.resharding.start({\n    targetShardCount: 5,\n    migrationConfig: Configure.Resharding.migration({\n      speed: 'medium',\n      batchSize: 1000\n    }),\n    validationSettings: Configure.Resharding.validation({\n      consistencyChecks: true,\n      errorThreshold: 0.01\n    })\n  });\n\n  // Monitor resharding progress\n  const status: ReshardingStatus = await articles.resharding.getStatus();\n  console.log(`Resharding progress: ${status.percentageComplete}%`);\n\n  // Handle potential rollback scenarios\n  if (status.status === 'FAILED') {\n    await articles.resharding.rollback();\n  }\n}\n\nperformResharding();\n// END ClusterResharding\n\nclient.close();"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java",
                "edits": [
                    {
                        "replace_section": "client.close();",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nimport io.weaviate.client.v1.cluster.model.ReshardingConfig;\nimport io.weaviate.client.v1.cluster.model.ReshardingStatus;\n\npublic void performResharding(String collectionName) {\n    // Doc writer / engineer TODO: Exact method to be confirmed\n    ReshardingConfig reshardingConfig = ReshardingConfig.builder()\n        .targetShardCount(5)\n        .migrationConfig(ReshardingConfig.MigrationConfig.builder()\n            .speed(\"medium\")\n            .batchSize(1000)\n            .build())\n        .validationSettings(ReshardingConfig.ValidationSettings.builder()\n            .consistencyChecks(true)\n            .errorThreshold(0.01f)\n            .build())\n        .build();\n\n    Result<ReshardingStatus> reshardingResult = client.cluster()\n        .reshardingStarter()\n        .withClassName(collectionName)\n        .withConfig(reshardingConfig)\n        .run();\n\n    if (reshardingResult.hasErrors()) {\n        System.out.println(\"Resharding failed: \" + reshardingResult.getError());\n        return;\n    }\n\n    ReshardingStatus status = reshardingResult.getResult();\n    System.out.printf(\"Resharding progress: %d%%%n\", status.getPercentageComplete());\n\n    // Handle potential rollback scenarios\n    if (status.getStatus().equals(\"FAILED\")) {\n        Result<Boolean> rollbackResult = client.cluster()\n            .reshardingRollback()\n            .withClassName(collectionName)\n            .run();\n\n        if (rollbackResult.hasErrors()) {\n            System.out.println(\"Rollback failed: \" + rollbackResult.getError());\n        }\n    }\n}\n// END ClusterResharding\n\nclient.close();"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/go/docs/manage-data.classes_test.go",
                "edits": [
                    {
                        "replace_section": "client.close()",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nfunc performResharding(t *testing.T, client *weaviate.Client, collectionName string) {\n    // Doc writer / engineer TODO: Exact method to be confirmed\n    reshardingConfig := &models.ReshardingConfig{\n        TargetShardCount: 5,\n        MigrationConfig: &models.ReshardingMigrationConfig{\n            Speed:     \"medium\",\n            BatchSize: 1000,\n        },\n        ValidationSettings: &models.ReshardingValidationSettings{\n            ConsistencyChecks: true,\n            ErrorThreshold:    0.01,\n        },\n    }\n\n    status, err := client.Cluster().\n        ReshardingStarter().\n        WithClassName(collectionName).\n        WithConfig(reshardingConfig).\n        Do(ctx)\n\n    if err != nil {\n        t.Fatalf(\"Resharding failed: %v\", err)\n    }\n\n    fmt.Printf(\"Resharding progress: %d%%\\n\", status.PercentageComplete)\n\n    // Handle potential rollback scenarios\n    if status.Status == \"FAILED\" {\n        _, rollbackErr := client.Cluster().\n            ReshardingRollback().\n            WithClassName(collectionName).\n            Do(ctx)\n\n        if rollbackErr != nil {\n            t.Fatalf(\"Rollback failed: %v\", rollbackErr)\n        }\n    }\n}\n// END ClusterResharding\n\nclient.close()"
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    },
    {
        "path": "docs/_includes/code/howto/manage-data.collections.py",
        "edits": [
            {
                "path": "docs/docs/weaviate/manage-collections/multi-node-setup.mdx",
                "edits": [
                    {
                        "replace_section": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)",
                        "replacement_txt": "## Update shard status\n\nYou can manually update a shard to change it's status. For example, update the shard status from `READONLY` to `READY` after you make other changes.\n\nimport CodeSchemaShardsUpdate from \"/_includes/code/howto/manage-data.shards.update.mdx\";\n\n<CodeSchemaShardsUpdate />\n\n## Cluster Resharding\n\nWeaviate now supports dynamic resharding of multi-node clusters to redistribute data across nodes, improving performance and scalability.\n\n### Key Features\n- Dynamically adjust the number of shards in an existing cluster without downtime\n- Automatic load balancing during migration to prevent node overload\n- Configurable batch sizes and migration speed throttling\n- Real-time consistency checks to ensure data integrity\n- Built-in rollback support in case of migration failures\n- Monitoring endpoints to track resharding progress\n\n### Resharding Configuration\n\nThe resharding operation is triggered via the `/v1/cluster/resharding` API endpoint with the following parameters:\n\n- `target_shard_count`: Desired number of shards after redistribution\n- `migration_speed`: Controls the rate of data migration\n- `validation_settings`: Configuration for data consistency checks\n\n:::note Client Libraries\nNative resharding functions for Weaviate client libraries (Python, JS/TS, Go, Java) will be available. Exact syntax is pending finalization.\n:::\n\n### Operational Behavior\n- Read operations continue normally during resharding\n- Write operations are temporarily queued and replayed after shard migration completes\n\n### Use Cases\n- Scaling up clusters under heavy load\n- Rebalancing after node additions or removals\n- Optimizing shard distribution for specific query performance patterns\n\nFor more details on the architectural implementation, see [Cluster Architecture](/weaviate/concepts/cluster-architecture).\n\n## Further resources\n\n- <SkipLink href=\"/weaviate/api/rest#tag/schema/post/schema\">API References: REST: Schema</SkipLink>\n- [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)\n- [Concepts: Data structure](../concepts/data.md)"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/manage-data.collections.py",
                "edits": [
                    {
                        "replace_section": "client.close()",
                        "replacement_txt": "# ===================================\n# ===== CLUSTER RESHARDING =====\n# ===================================\n\n# START ClusterResharding\nfrom weaviate.classes.config import Configure\n\n# Initiate resharding operation\narticles = client.collections.use(\"Article\")\n\n# Doc writer / engineer TODO: Exact method to be confirmed\nresult = articles.resharding.start(\n    target_shard_count=5,  # New number of desired shards\n    migration_config=Configure.Resharding.migration(\n        speed=\"medium\",  # Throttling configuration\n        batch_size=1000  # Number of vectors per batch\n    ),\n    validation_settings=Configure.Resharding.validation(\n        consistency_checks=True,\n        error_threshold=0.01  # Maximum acceptable error rate\n    )\n)\n\n# Monitor resharding progress\nprogress = articles.resharding.get_status()\nprint(f\"Resharding progress: {progress.percentage_complete}%\")\n\n# Handle potential rollback scenarios\nif progress.status == \"FAILED\":\n    articles.resharding.rollback()\n# END ClusterResharding\n\nclient.close()"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/manage-data.collections.ts",
                "edits": [
                    {
                        "replace_section": "client.close();",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nimport { Configure, ReshardingStatus } from 'weaviate-client';\n\nasync function performResharding() {\n  const articles = client.collections.use('Article');\n\n  // Doc writer / engineer TODO: Exact method to be confirmed\n  const reshardingOperation = await articles.resharding.start({\n    targetShardCount: 5,\n    migrationConfig: Configure.Resharding.migration({\n      speed: 'medium',\n      batchSize: 1000\n    }),\n    validationSettings: Configure.Resharding.validation({\n      consistencyChecks: true,\n      errorThreshold: 0.01\n    })\n  });\n\n  // Monitor resharding progress\n  const status: ReshardingStatus = await articles.resharding.getStatus();\n  console.log(`Resharding progress: ${status.percentageComplete}%`);\n\n  // Handle potential rollback scenarios\n  if (status.status === 'FAILED') {\n    await articles.resharding.rollback();\n  }\n}\n\nperformResharding();\n// END ClusterResharding\n\nclient.close();"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java",
                "edits": [
                    {
                        "replace_section": "client.close();",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nimport io.weaviate.client.v1.cluster.model.ReshardingConfig;\nimport io.weaviate.client.v1.cluster.model.ReshardingStatus;\n\npublic void performResharding(String collectionName) {\n    // Doc writer / engineer TODO: Exact method to be confirmed\n    ReshardingConfig reshardingConfig = ReshardingConfig.builder()\n        .targetShardCount(5)\n        .migrationConfig(ReshardingConfig.MigrationConfig.builder()\n            .speed(\"medium\")\n            .batchSize(1000)\n            .build())\n        .validationSettings(ReshardingConfig.ValidationSettings.builder()\n            .consistencyChecks(true)\n            .errorThreshold(0.01f)\n            .build())\n        .build();\n\n    Result<ReshardingStatus> reshardingResult = client.cluster()\n        .reshardingStarter()\n        .withClassName(collectionName)\n        .withConfig(reshardingConfig)\n        .run();\n\n    if (reshardingResult.hasErrors()) {\n        System.out.println(\"Resharding failed: \" + reshardingResult.getError());\n        return;\n    }\n\n    ReshardingStatus status = reshardingResult.getResult();\n    System.out.printf(\"Resharding progress: %d%%%n\", status.getPercentageComplete());\n\n    // Handle potential rollback scenarios\n    if (status.getStatus().equals(\"FAILED\")) {\n        Result<Boolean> rollbackResult = client.cluster()\n            .reshardingRollback()\n            .withClassName(collectionName)\n            .run();\n\n        if (rollbackResult.hasErrors()) {\n            System.out.println(\"Rollback failed: \" + rollbackResult.getError());\n        }\n    }\n}\n// END ClusterResharding\n\nclient.close();"
                    }
                ],
                "referenced_file_edits": {}
            },
            {
                "path": "docs/_includes/code/howto/go/docs/manage-data.classes_test.go",
                "edits": [
                    {
                        "replace_section": "client.close()",
                        "replacement_txt": "// ===================================\n// ===== CLUSTER RESHARDING =====\n// ===================================\n\n// START ClusterResharding\nfunc performResharding(t *testing.T, client *weaviate.Client, collectionName string) {\n    // Doc writer / engineer TODO: Exact method to be confirmed\n    reshardingConfig := &models.ReshardingConfig{\n        TargetShardCount: 5,\n        MigrationConfig: &models.ReshardingMigrationConfig{\n            Speed:     \"medium\",\n            BatchSize: 1000,\n        },\n        ValidationSettings: &models.ReshardingValidationSettings{\n            ConsistencyChecks: true,\n            ErrorThreshold:    0.01,\n        },\n    }\n\n    status, err := client.Cluster().\n        ReshardingStarter().\n        WithClassName(collectionName).\n        WithConfig(reshardingConfig).\n        Do(ctx)\n\n    if err != nil {\n        t.Fatalf(\"Resharding failed: %v\", err)\n    }\n\n    fmt.Printf(\"Resharding progress: %d%%\\n\", status.PercentageComplete)\n\n    // Handle potential rollback scenarios\n    if status.Status == \"FAILED\" {\n        _, rollbackErr := client.Cluster().\n            ReshardingRollback().\n            WithClassName(collectionName).\n            Do(ctx)\n\n        if rollbackErr != nil {\n            t.Fatalf(\"Rollback failed: %v\", rollbackErr)\n        }\n    }\n}\n// END ClusterResharding\n\nclient.close()"
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    },
    {
        "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
        "edits": [
            {
                "path": "docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md",
                "edits": [
                    {
                        "replace_section": "On the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n\n## Replication Factor",
                        "replacement_txt": "On the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.\n\n## Dynamic Resharding\n\nIn response to evolving cluster performance needs, Weaviate now supports dynamic resharding, a sophisticated mechanism that allows administrators to redistribute data across nodes without system downtime. This feature enhances the leaderless architecture by providing granular control over data distribution and load balancing.\n\n### Resharding Mechanism\n\nDynamic resharding works by creating new shard mappings and migrating vector embeddings and metadata in carefully controlled batches. The process involves:\n\n1. **Shard Mapping Reconfiguration**: Generate a new distributed hash ring that defines how data will be redistributed across nodes.\n2. **Batch Migration**: Transfer vector embeddings and metadata in configurable batch sizes to minimize performance impact.\n3. **Distributed Coordination**: Leverage the existing leaderless coordination pattern to manage migration without disrupting the overall system architecture.\n\n### Key Capabilities\n\n- **Automatic Load Balancing**: Intelligent migration algorithms prevent node overload during resharding.\n- **Configurable Migration**: Administrators can control batch sizes and migration speed to minimize performance interruptions.\n- **Consistency Guarantees**: Real-time consistency checks ensure data integrity throughout the resharding process.\n- **Operational Safety**: \n  - Rollback support in case of migration failures\n  - Monitoring endpoints to track resharding progress\n  - Minimal disruption to existing read/write patterns\n\n### Impact on Operations\n\nDuring resharding:\n- Read operations continue normally without interruption\n- Write operations are temporarily queued and replayed after shard migration completes\n- No downtime is required for the cluster\n\n### Use Cases\n\nDynamic resharding is particularly valuable in scenarios such as:\n- Scaling clusters under heavy load\n- Rebalancing after node additions or removals\n- Optimizing shard distribution for specific query performance patterns\n\n:::note Implementation Details\nFor specific implementation instructions, refer to the [Cluster Resharding](/path/to/resharding/guide) documentation.\n:::\n\n## Replication Factor"
                    }
                ],
                "referenced_file_edits": {}
            }
        ]
    }
]