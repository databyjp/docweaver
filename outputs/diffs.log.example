--- a/docs/docs/weaviate/concepts/cluster.md
+++ b/docs/docs/weaviate/concepts/cluster.md
@@ -161,11 +161,37 @@

 ## Consistency and current limitations

 * Starting with `v1.25.0`, Weaviate adopts the [Raft consensus algorithm](https://raft.github.io/) which is a log-based algorithm coordinated by an elected leader. This brings an additional benefit in that concurrent schema changes are now supported.<br/>If you are a Kubernetes user, see the [`1.25 migration guide`](/deploy/migration/weaviate-1-25.md) before you upgrade. To upgrade, you have to delete your existing StatefulSet.
 * As of `v1.8.0`, the process of broadcasting schema changes across the cluster uses a form of two-phase transaction that as of now cannot tolerate node failures during the lifetime of the transaction.
-* As of `v1.8.0`, dynamically scaling a cluster is not fully supported yet. New nodes can be added to an existing cluster, however it does not affect the ownership of shards. Existing nodes can not yet be removed if data is present, as shards are not yet being moved to other nodes prior to a removal of a node.
+* With the introduction of cluster resharding, Weaviate now supports dynamic scaling of clusters, allowing administrators to redistribute data across nodes efficiently and without downtime.
+
+## Cluster Resharding
+
+Weaviate now supports dynamic cluster resharding, a powerful feature that allows administrators to redistribute data across nodes for improved performance and scalability. This capability enables you to adjust the number of shards in an existing cluster without experiencing downtime.
+
+### Key Resharding Capabilities
+
+- **Automatic Load Balancing**: Prevents node overload during data migration
+- **Configurable Migration**: Control batch sizes and migration speed
+- **Data Integrity**: Real-time consistency checks ensure data accuracy
+- **Resilience**: Rollback support in case of migration failures
+- **Monitoring**: Dedicated endpoints to track resharding progress
+
+### Resharding Process
+
+Resharding is triggered via the `/v1/cluster/resharding` API endpoint. During the resharding operation:
+- Read operations continue normally
+- Write operations are temporarily queued and replayed after shard migration completes
+
+### Typical Use Cases
+
+1. **Scaling Under Heavy Load**: Redistribute data when cluster performance becomes constrained
+2. **Node Rebalancing**: Optimize data distribution after adding or removing nodes
+3. **Query Performance Optimization**: Adjust shard distribution to match evolving query patterns
+
+For specific API usage and configuration details, refer to the [multi-node setup documentation](/docs/weaviate/manage-collections/multi-node-setup.mdx).

 ## Questions and feedback

 import DocsFeedback from '/_includes/docs-feedback.mdx';

--- a/docs/docs/weaviate/manage-collections/multi-node-setup.mdx
+++ b/docs/docs/weaviate/manage-collections/multi-node-setup.mdx
@@ -200,10 +200,45 @@

 import CodeSchemaShardsUpdate from "/_includes/code/howto/manage-data.shards.update.mdx";

 <CodeSchemaShardsUpdate />

+## Cluster Resharding
+
+Weaviate now supports dynamic resharding of multi-node clusters to redistribute data across nodes, improving performance and scalability.
+
+### Key Features
+- Dynamically adjust the number of shards in an existing cluster without downtime
+- Automatic load balancing during migration to prevent node overload
+- Configurable batch sizes and migration speed throttling
+- Real-time consistency checks to ensure data integrity
+- Built-in rollback support in case of migration failures
+- Monitoring endpoints to track resharding progress
+
+### Resharding Configuration
+
+The resharding operation is triggered via the `/v1/cluster/resharding` API endpoint with the following parameters:
+
+- `target_shard_count`: Desired number of shards after redistribution
+- `migration_speed`: Controls the rate of data migration
+- `validation_settings`: Configuration for data consistency checks
+
+:::note Client Libraries
+Native resharding functions for Weaviate client libraries (Python, JS/TS, Go, Java) will be available. Exact syntax is pending finalization.
+:::
+
+### Operational Behavior
+- Read operations continue normally during resharding
+- Write operations are temporarily queued and replayed after shard migration completes
+
+### Use Cases
+- Scaling up clusters under heavy load
+- Rebalancing after node additions or removals
+- Optimizing shard distribution for specific query performance patterns
+
+For more details on the architectural implementation, see [Cluster Architecture](/weaviate/concepts/cluster-architecture).
+
 ## Further resources

 - <SkipLink href="/weaviate/api/rest#tag/schema/post/schema">API References: REST: Schema</SkipLink>
 - [References: Configuration: Schema](/weaviate/config-refs/collections.mdx)
 - [Concepts: Data structure](../concepts/data.md)
--- a/docs/_includes/code/howto/manage-data.collections.py
+++ b/docs/_includes/code/howto/manage-data.collections.py
@@ -652,10 +652,42 @@
 # Test
 collection = client.collections.use("Article")
 config = collection.config.get()
 assert config.vector_config["default"].vector_index_config.distance_metric.value == "cosine"

+# ===================================
+# ===== CLUSTER RESHARDING =====
+# ===================================
+
+# START ClusterResharding
+from weaviate.classes.config import Configure
+
+# Initiate resharding operation
+articles = client.collections.use("Article")
+
+# Doc writer / engineer TODO: Exact method to be confirmed
+result = articles.resharding.start(
+    target_shard_count=5,  # New number of desired shards
+    migration_config=Configure.Resharding.migration(
+        speed="medium",  # Throttling configuration
+        batch_size=1000  # Number of vectors per batch
+    ),
+    validation_settings=Configure.Resharding.validation(
+        consistency_checks=True,
+        error_threshold=0.01  # Maximum acceptable error rate
+    )
+)
+
+# Monitor resharding progress
+progress = articles.resharding.get_status()
+print(f"Resharding progress: {progress.percentage_complete}%")
+
+# Handle potential rollback scenarios
+if progress.status == "FAILED":
+    articles.resharding.rollback()
+# END ClusterResharding
+
 client.close()

 # =======================
 # ===== REPLICATION =====
 # =======================
@@ -680,10 +712,42 @@
 # Test
 collection = client.collections.use("Article")
 config = collection.config.get()
 assert config.replication_config.factor == 3

+# ===================================
+# ===== CLUSTER RESHARDING =====
+# ===================================
+
+# START ClusterResharding
+from weaviate.classes.config import Configure
+
+# Initiate resharding operation
+articles = client.collections.use("Article")
+
+# Doc writer / engineer TODO: Exact method to be confirmed
+result = articles.resharding.start(
+    target_shard_count=5,  # New number of desired shards
+    migration_config=Configure.Resharding.migration(
+        speed="medium",  # Throttling configuration
+        batch_size=1000  # Number of vectors per batch
+    ),
+    validation_settings=Configure.Resharding.validation(
+        consistency_checks=True,
+        error_threshold=0.01  # Maximum acceptable error rate
+    )
+)
+
+# Monitor resharding progress
+progress = articles.resharding.get_status()
+print(f"Resharding progress: {progress.percentage_complete}%")
+
+# Handle potential rollback scenarios
+if progress.status == "FAILED":
+    articles.resharding.rollback()
+# END ClusterResharding
+
 client.close()

 # =======================
 # ===== REPLICATION WITH ASYNC REPAIR ====
 # =======================
@@ -710,10 +774,42 @@

 # Test
 collection = client.collections.use("Article")
 config = collection.config.get()
 # assert config.replication_config.factor == 3   #ASYNC NEEDS TEST
+
+# ===================================
+# ===== CLUSTER RESHARDING =====
+# ===================================
+
+# START ClusterResharding
+from weaviate.classes.config import Configure
+
+# Initiate resharding operation
+articles = client.collections.use("Article")
+
+# Doc writer / engineer TODO: Exact method to be confirmed
+result = articles.resharding.start(
+    target_shard_count=5,  # New number of desired shards
+    migration_config=Configure.Resharding.migration(
+        speed="medium",  # Throttling configuration
+        batch_size=1000  # Number of vectors per batch
+    ),
+    validation_settings=Configure.Resharding.validation(
+        consistency_checks=True,
+        error_threshold=0.01  # Maximum acceptable error rate
+    )
+)
+
+# Monitor resharding progress
+progress = articles.resharding.get_status()
+print(f"Resharding progress: {progress.percentage_complete}%")
+
+# Handle potential rollback scenarios
+if progress.status == "FAILED":
+    articles.resharding.rollback()
+# END ClusterResharding

 client.close()

 # ==============================================
 # ===== ALL REPLICATION SETTINGS
@@ -746,10 +842,42 @@
 assert config.replication_config.async_enabled == True
 assert (
     config.replication_config.deletion_strategy
     == ReplicationDeletionStrategy.TIME_BASED_RESOLUTION
 )
+
+# ===================================
+# ===== CLUSTER RESHARDING =====
+# ===================================
+
+# START ClusterResharding
+from weaviate.classes.config import Configure
+
+# Initiate resharding operation
+articles = client.collections.use("Article")
+
+# Doc writer / engineer TODO: Exact method to be confirmed
+result = articles.resharding.start(
+    target_shard_count=5,  # New number of desired shards
+    migration_config=Configure.Resharding.migration(
+        speed="medium",  # Throttling configuration
+        batch_size=1000  # Number of vectors per batch
+    ),
+    validation_settings=Configure.Resharding.validation(
+        consistency_checks=True,
+        error_threshold=0.01  # Maximum acceptable error rate
+    )
+)
+
+# Monitor resharding progress
+progress = articles.resharding.get_status()
+print(f"Resharding progress: {progress.percentage_complete}%")
+
+# Handle potential rollback scenarios
+if progress.status == "FAILED":
+    articles.resharding.rollback()
+# END ClusterResharding

 client.close()

 # ====================
 # ===== SHARDING =====
@@ -995,6 +1123,38 @@

 print(article_shards)
 # END UpdateCollectionShards


+# ===================================
+# ===== CLUSTER RESHARDING =====
+# ===================================
+
+# START ClusterResharding
+from weaviate.classes.config import Configure
+
+# Initiate resharding operation
+articles = client.collections.use("Article")
+
+# Doc writer / engineer TODO: Exact method to be confirmed
+result = articles.resharding.start(
+    target_shard_count=5,  # New number of desired shards
+    migration_config=Configure.Resharding.migration(
+        speed="medium",  # Throttling configuration
+        batch_size=1000  # Number of vectors per batch
+    ),
+    validation_settings=Configure.Resharding.validation(
+        consistency_checks=True,
+        error_threshold=0.01  # Maximum acceptable error rate
+    )
+)
+
+# Monitor resharding progress
+progress = articles.resharding.get_status()
+print(f"Resharding progress: {progress.percentage_complete}%")
+
+# Handle potential rollback scenarios
+if progress.status == "FAILED":
+    articles.resharding.rollback()
+# END ClusterResharding
+
 client.close()
--- a/docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md
+++ b/docs/docs/weaviate/concepts/replication-architecture/cluster-architecture.md
@@ -75,10 +75,49 @@

 The main advantage of a leaderless replication design is improved fault tolerance. Without a leader that handles all requests, a leaderless design offers better availability. In a single-leader design, all writes need to be processed by this leader. If this node cannot be reached or goes down, no writes can be processed. With a leaderless design, all nodes can receive write operations, so there is no risk of one master node failing.

 On the flipside of high availability, a leaderless database tends to be less consistent. Because there is no leader node, data on different nodes may temporarily be out of date. Leaderless databases tend to be eventually consistent. Consistency in Weaviate is [tunable](./consistency.md), but this occurs at the expense of availability.

+## Dynamic Resharding
+
+In response to evolving cluster performance needs, Weaviate now supports dynamic resharding, a sophisticated mechanism that allows administrators to redistribute data across nodes without system downtime. This feature enhances the leaderless architecture by providing granular control over data distribution and load balancing.
+
+### Resharding Mechanism
+
+Dynamic resharding works by creating new shard mappings and migrating vector embeddings and metadata in carefully controlled batches. The process involves:
+
+1. **Shard Mapping Reconfiguration**: Generate a new distributed hash ring that defines how data will be redistributed across nodes.
+2. **Batch Migration**: Transfer vector embeddings and metadata in configurable batch sizes to minimize performance impact.
+3. **Distributed Coordination**: Leverage the existing leaderless coordination pattern to manage migration without disrupting the overall system architecture.
+
+### Key Capabilities
+
+- **Automatic Load Balancing**: Intelligent migration algorithms prevent node overload during resharding.
+- **Configurable Migration**: Administrators can control batch sizes and migration speed to minimize performance interruptions.
+- **Consistency Guarantees**: Real-time consistency checks ensure data integrity throughout the resharding process.
+- **Operational Safety**:
+  - Rollback support in case of migration failures
+  - Monitoring endpoints to track resharding progress
+  - Minimal disruption to existing read/write patterns
+
+### Impact on Operations
+
+During resharding:
+- Read operations continue normally without interruption
+- Write operations are temporarily queued and replayed after shard migration completes
+- No downtime is required for the cluster
+
+### Use Cases
+
+Dynamic resharding is particularly valuable in scenarios such as:
+- Scaling clusters under heavy load
+- Rebalancing after node additions or removals
+- Optimizing shard distribution for specific query performance patterns
+
+:::note Implementation Details
+For specific implementation instructions, refer to the [Cluster Resharding](/path/to/resharding/guide) documentation.
+:::

 ## Replication Factor

 import RaftRFChangeWarning from '/_includes/1-25-replication-factor.mdx';

